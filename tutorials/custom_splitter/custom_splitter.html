

<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Build your own training/testing split &mdash; lightwood 25.3.3.2 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css" />
      <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css" />
      <link rel="stylesheet" type="text/css" href="../../_static/nbsphinx-code-cells.css" />
      <link rel="stylesheet" type="text/css" href="../../_static/custom.css" />

  
      <script src="../../_static/jquery.js"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
      <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
      <script src="../../_static/doctools.js"></script>
      <script src="../../_static/sphinx_highlight.js"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
      <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
      <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: white" >

          
          
          <a href="../../index.html">
            
              <img src="../../_static/mindsdblogo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../tutorials.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">Tutorials</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">API</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../data.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">Data</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../encoder.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">Encoders</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mixer.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">Mixers</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ensemble.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">Ensemble</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../analysis.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">Analysis</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../helpers.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">Helpers</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../lightwood_philosophy.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">Lightwood</span> <span class="pre">Philosophy</span></code></a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: white" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">lightwood</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Build your own training/testing split</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/tutorials/custom_splitter/custom_splitter.ipynb.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="Build-your-own-training/testing-split">
<h1>Build your own training/testing split<a class="headerlink" href="#Build-your-own-training/testing-split" title="Permalink to this heading"></a></h1>
<section id="Date:-2021.10.07">
<h2>Date: 2021.10.07<a class="headerlink" href="#Date:-2021.10.07" title="Permalink to this heading"></a></h2>
<p>When working with machine learning data, splitting into a “train”, “dev” (or validation) and “test”) set is important. Models use <strong>train</strong> data to learn representations and update their parameters; <strong>dev</strong> or validation data is reserved to see how the model may perform on unknown predictions. While it may not be explicitly trained on, it can be used as a stopping criteria, for hyper-parameter tuning, or as a simple sanity check. Lastly, <strong>test</strong> data is always reserved, hidden from the model,
as a final pass to see what models perform best.</p>
<p>Lightwood supports a variety of <strong>encoders</strong> (Feature engineering procedures) and <strong>mixers</strong> (predictor algorithms that go from feature vectors to the target). Given the diversity of algorithms, it is appropriate to split data into these three categories when <em>preparing</em> encoders or <em>fitting</em> mixers.</p>
<p>Our default approach stratifies labeled data to ensure your train, validation, and test sets are equally represented in all classes. However, in many instances you may want a custom technique to build your own splits. We’ve included the <code class="docutils literal notranslate"><span class="pre">splitter</span></code> functionality (default found in <code class="docutils literal notranslate"><span class="pre">lightwood.data.splitter</span></code>) to enable you to build your own.</p>
<p>In the following problem, we shall work with a Kaggle dataset around credit card fraud (found <a class="reference external" href="https://www.kaggle.com/mlg-ulb/creditcardfraud">here</a>). Fraud detection is difficult because the events we are interested in catching are thankfully rare events. Because of that, there is a large <strong>imbalance of classes</strong> (in fact, in this dataset, less than 1% of the data are the rare-event).</p>
<p>In a supervised technique, we may want to ensure our training data sees the rare event of interest. A random shuffle could potentially miss rare events. We will implement <strong>SMOTE</strong> to increase the number of positive classes in our training data.</p>
<p>Let’s get started!</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[1]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">nltk</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">os</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">sys</span>

<span class="c1"># Lightwood modules</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">lightwood</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">lw</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">lightwood</span><span class="w"> </span><span class="kn">import</span> <span class="n">ProblemDefinition</span><span class="p">,</span> \
                      <span class="n">JsonAI</span><span class="p">,</span> \
                      <span class="n">json_ai_from_problem</span><span class="p">,</span> \
                      <span class="n">code_from_json_ai</span><span class="p">,</span> \
                      <span class="n">predictor_from_code</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">imblearn</span> <span class="c1"># Vers 0.5.0 minimum requirement</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area stderr docutils container">
<div class="highlight"><pre>
<span class="ansi-green-fg">INFO:lightwood-2968:No torchvision detected, image helpers not supported.</span>
<span class="ansi-green-fg">INFO:lightwood-2968:No torchvision/pillow detected, image encoder not supported</span>
</pre></div></div>
</div>
<section id="1)-Load-your-data">
<h3>1) Load your data<a class="headerlink" href="#1)-Load-your-data" title="Permalink to this heading"></a></h3>
<p>Lightwood works with <code class="docutils literal notranslate"><span class="pre">pandas</span></code> DataFrames. We can use pandas to load our data. Please download the dataset from the above link and place it in a folder called <code class="docutils literal notranslate"><span class="pre">data/</span></code> where this notebook is located.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[2]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Load the data</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s2">&quot;https://mindsdb-example-data.s3.eu-west-2.amazonaws.com/jupyter/creditcard.csv.zip&quot;</span><span class="p">)</span>
<span class="n">data</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[2]:
</pre></div>
</div>
<div class="output_area rendered_html docutils container">
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Time</th>
      <th>V1</th>
      <th>V2</th>
      <th>V3</th>
      <th>V4</th>
      <th>V5</th>
      <th>V6</th>
      <th>V7</th>
      <th>V8</th>
      <th>V9</th>
      <th>...</th>
      <th>V21</th>
      <th>V22</th>
      <th>V23</th>
      <th>V24</th>
      <th>V25</th>
      <th>V26</th>
      <th>V27</th>
      <th>V28</th>
      <th>Amount</th>
      <th>Class</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0.0</td>
      <td>-1.359807</td>
      <td>-0.072781</td>
      <td>2.536347</td>
      <td>1.378155</td>
      <td>-0.338321</td>
      <td>0.462388</td>
      <td>0.239599</td>
      <td>0.098698</td>
      <td>0.363787</td>
      <td>...</td>
      <td>-0.018307</td>
      <td>0.277838</td>
      <td>-0.110474</td>
      <td>0.066928</td>
      <td>0.128539</td>
      <td>-0.189115</td>
      <td>0.133558</td>
      <td>-0.021053</td>
      <td>149.62</td>
      <td>0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>0.0</td>
      <td>1.191857</td>
      <td>0.266151</td>
      <td>0.166480</td>
      <td>0.448154</td>
      <td>0.060018</td>
      <td>-0.082361</td>
      <td>-0.078803</td>
      <td>0.085102</td>
      <td>-0.255425</td>
      <td>...</td>
      <td>-0.225775</td>
      <td>-0.638672</td>
      <td>0.101288</td>
      <td>-0.339846</td>
      <td>0.167170</td>
      <td>0.125895</td>
      <td>-0.008983</td>
      <td>0.014724</td>
      <td>2.69</td>
      <td>0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>1.0</td>
      <td>-1.358354</td>
      <td>-1.340163</td>
      <td>1.773209</td>
      <td>0.379780</td>
      <td>-0.503198</td>
      <td>1.800499</td>
      <td>0.791461</td>
      <td>0.247676</td>
      <td>-1.514654</td>
      <td>...</td>
      <td>0.247998</td>
      <td>0.771679</td>
      <td>0.909412</td>
      <td>-0.689281</td>
      <td>-0.327642</td>
      <td>-0.139097</td>
      <td>-0.055353</td>
      <td>-0.059752</td>
      <td>378.66</td>
      <td>0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>1.0</td>
      <td>-0.966272</td>
      <td>-0.185226</td>
      <td>1.792993</td>
      <td>-0.863291</td>
      <td>-0.010309</td>
      <td>1.247203</td>
      <td>0.237609</td>
      <td>0.377436</td>
      <td>-1.387024</td>
      <td>...</td>
      <td>-0.108300</td>
      <td>0.005274</td>
      <td>-0.190321</td>
      <td>-1.175575</td>
      <td>0.647376</td>
      <td>-0.221929</td>
      <td>0.062723</td>
      <td>0.061458</td>
      <td>123.50</td>
      <td>0</td>
    </tr>
    <tr>
      <th>4</th>
      <td>2.0</td>
      <td>-1.158233</td>
      <td>0.877737</td>
      <td>1.548718</td>
      <td>0.403034</td>
      <td>-0.407193</td>
      <td>0.095921</td>
      <td>0.592941</td>
      <td>-0.270533</td>
      <td>0.817739</td>
      <td>...</td>
      <td>-0.009431</td>
      <td>0.798278</td>
      <td>-0.137458</td>
      <td>0.141267</td>
      <td>-0.206010</td>
      <td>0.502292</td>
      <td>0.219422</td>
      <td>0.215153</td>
      <td>69.99</td>
      <td>0</td>
    </tr>
  </tbody>
</table>
<p>5 rows × 31 columns</p>
</div></div>
</div>
<p>We see <strong>31 columns</strong>, most of these columns appear numerical. Due to confidentiality reasons, the Kaggle dataset mentions that the columns labeled <span class="math notranslate nohighlight">\(V_i\)</span> indicate principle components (PCs) from a PCA analysis of the original data from the credit card company. There is also a “Time” and “Amount”, two original features that remained. The time references time after the first transaction in the dataset, and amount is how much money was considered in the transaction.</p>
<p>You can also see a heavy imbalance in the two classes below:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[3]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">f</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;Class&#39;</span><span class="p">],</span> <span class="n">bins</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">,</span> <span class="mf">1.1</span><span class="p">],</span> <span class="n">log</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Log Counts&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xticklabels</span><span class="p">([</span><span class="s2">&quot;0&quot;</span><span class="p">,</span> <span class="s2">&quot;1&quot;</span><span class="p">])</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Class&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Distribution of Classes&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[3]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Text(0.5, 1.0, &#39;Distribution of Classes&#39;)
</pre></div></div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../../_images/tutorials_custom_splitter_custom_splitter_5_1.png" src="../../_images/tutorials_custom_splitter_custom_splitter_5_1.png" />
</div>
</div>
</section>
<section id="2)-Create-a-JSON-AI-default-object">
<h3>2) Create a JSON-AI default object<a class="headerlink" href="#2)-Create-a-JSON-AI-default-object" title="Permalink to this heading"></a></h3>
<p>We will now create JSON-AI syntax for our problem based on its specifications. We can do so by setting up a <code class="docutils literal notranslate"><span class="pre">ProblemDefinition</span></code>. The <code class="docutils literal notranslate"><span class="pre">ProblemDefinition</span></code> allows us to specify the target, the column we intend to predict, along with other details.</p>
<p>The end goal of JSON-AI is to provide **a set of instructions on how to compile a machine learning pipeline*.</p>
<p>Our target here is called “<strong>Class</strong>”, which indicates “0” for no fraud and “1” for fraud. We’ll generate the JSON-AI with the minimal syntax:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[4]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Setup the problem definition</span>
<span class="n">problem_definition</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;target&#39;</span><span class="p">:</span> <span class="s1">&#39;Class&#39;</span><span class="p">,</span>
<span class="p">}</span>

<span class="c1"># Generate the j{ai}son syntax</span>
<span class="n">json_ai</span> <span class="o">=</span> <span class="n">json_ai_from_problem</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">problem_definition</span><span class="p">)</span>
<br/></pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area stderr docutils container">
<div class="highlight"><pre>
<span class="ansi-green-fg">INFO:type_infer-2968:Analyzing a sample of 18424</span>
<span class="ansi-green-fg">INFO:type_infer-2968:from a total population of 284807, this is equivalent to 6.5% of your data.</span>
<span class="ansi-green-fg">INFO:type_infer-2968:Using 3 processes to deduct types.</span>
<span class="ansi-green-fg">INFO:type_infer-2968:Infering type for: Time</span>
<span class="ansi-green-fg">INFO:type_infer-2968:Infering type for: V3</span>
<span class="ansi-green-fg">INFO:type_infer-2968:Infering type for: V6</span>
<span class="ansi-green-fg">INFO:type_infer-2968:Column Time has data type integer</span>
<span class="ansi-green-fg">INFO:type_infer-2968:Infering type for: V1</span>
<span class="ansi-green-fg">INFO:type_infer-2968:Column V3 has data type float</span>
<span class="ansi-green-fg">INFO:type_infer-2968:Infering type for: V4</span>
<span class="ansi-green-fg">INFO:type_infer-2968:Column V4 has data type float</span>
<span class="ansi-green-fg">INFO:type_infer-2968:Infering type for: V5</span>
<span class="ansi-green-fg">INFO:type_infer-2968:Column V6 has data type float</span>
<span class="ansi-green-fg">INFO:type_infer-2968:Infering type for: V7</span>
<span class="ansi-green-fg">INFO:type_infer-2968:Column V1 has data type float</span>
<span class="ansi-green-fg">INFO:type_infer-2968:Infering type for: V2</span>
<span class="ansi-green-fg">INFO:type_infer-2968:Column V5 has data type float</span>
<span class="ansi-green-fg">INFO:type_infer-2968:Infering type for: V9</span>
<span class="ansi-green-fg">INFO:type_infer-2968:Column V7 has data type float</span>
<span class="ansi-green-fg">INFO:type_infer-2968:Infering type for: V8</span>
<span class="ansi-green-fg">INFO:type_infer-2968:Column V9 has data type float</span>
<span class="ansi-green-fg">INFO:type_infer-2968:Infering type for: V10</span>
<span class="ansi-green-fg">INFO:type_infer-2968:Column V2 has data type float</span>
<span class="ansi-green-fg">INFO:type_infer-2968:Infering type for: V12</span>
<span class="ansi-green-fg">INFO:type_infer-2968:Column V10 has data type float</span>
<span class="ansi-green-fg">INFO:type_infer-2968:Infering type for: V11</span>
<span class="ansi-green-fg">INFO:type_infer-2968:Column V8 has data type float</span>
<span class="ansi-green-fg">INFO:type_infer-2968:Infering type for: V15</span>
<span class="ansi-green-fg">INFO:type_infer-2968:Column V12 has data type float</span>
<span class="ansi-green-fg">INFO:type_infer-2968:Infering type for: V13</span>
<span class="ansi-green-fg">INFO:type_infer-2968:Column V11 has data type float</span>
<span class="ansi-green-fg">INFO:type_infer-2968:Infering type for: V18</span>
<span class="ansi-green-fg">INFO:type_infer-2968:Column V15 has data type float</span>
<span class="ansi-green-fg">INFO:type_infer-2968:Infering type for: V16</span>
<span class="ansi-green-fg">INFO:type_infer-2968:Column V18 has data type float</span>
<span class="ansi-green-fg">INFO:type_infer-2968:Infering type for: V19</span>
<span class="ansi-green-fg">INFO:type_infer-2968:Column V13 has data type float</span>
<span class="ansi-green-fg">INFO:type_infer-2968:Infering type for: V14</span>
<span class="ansi-green-fg">INFO:type_infer-2968:Column V19 has data type float</span>
<span class="ansi-green-fg">INFO:type_infer-2968:Infering type for: V20</span>
<span class="ansi-green-fg">INFO:type_infer-2968:Column V16 has data type float</span>
<span class="ansi-green-fg">INFO:type_infer-2968:Infering type for: V17</span>
<span class="ansi-green-fg">INFO:type_infer-2968:Column V14 has data type float</span>
<span class="ansi-green-fg">INFO:type_infer-2968:Column V20 has data type float</span>
<span class="ansi-green-fg">INFO:type_infer-2968:Infering type for: V21</span>
<span class="ansi-green-fg">INFO:type_infer-2968:Infering type for: V24</span>
<span class="ansi-green-fg">INFO:type_infer-2968:Column V17 has data type float</span>
<span class="ansi-green-fg">INFO:type_infer-2968:Column V24 has data type float</span>
<span class="ansi-green-fg">INFO:type_infer-2968:Infering type for: V25</span>
<span class="ansi-green-fg">INFO:type_infer-2968:Infering type for: V27</span>
<span class="ansi-green-fg">INFO:type_infer-2968:Column V21 has data type float</span>
<span class="ansi-green-fg">INFO:type_infer-2968:Infering type for: V22</span>
<span class="ansi-green-fg">INFO:type_infer-2968:Column V22 has data type float</span>
<span class="ansi-green-fg">INFO:type_infer-2968:Infering type for: V23</span>
<span class="ansi-green-fg">INFO:type_infer-2968:Column V25 has data type float</span>
<span class="ansi-green-fg">INFO:type_infer-2968:Infering type for: V26</span>
<span class="ansi-green-fg">INFO:type_infer-2968:Column V27 has data type float</span>
<span class="ansi-green-fg">INFO:type_infer-2968:Infering type for: V28</span>
<span class="ansi-green-fg">INFO:type_infer-2968:Column V23 has data type float</span>
<span class="ansi-green-fg">INFO:type_infer-2968:Infering type for: Class</span>
<span class="ansi-green-fg">INFO:type_infer-2968:Column Class has data type binary</span>
<span class="ansi-green-fg">INFO:type_infer-2968:Column V26 has data type float</span>
<span class="ansi-green-fg">INFO:type_infer-2968:Column V28 has data type float</span>
<span class="ansi-green-fg">INFO:type_infer-2968:Infering type for: Amount</span>
<span class="ansi-green-fg">INFO:type_infer-2968:Column Amount has data type float</span>
<span class="ansi-green-fg">INFO:dataprep_ml-2968:Starting statistical analysis</span>
<span class="ansi-green-fg">INFO:dataprep_ml-2968:Finished statistical analysis</span>
</pre></div></div>
</div>
<p>Lightwood looks at each of the many columns and indicates they are mostly float, with exception of “<strong>Class</strong>” which is binary.</p>
<p>You can observe the JSON-AI if you run the command <code class="docutils literal notranslate"><span class="pre">print(json_ai.to_json())</span></code>. Given there are many input features, we won’t print it out.</p>
<p>These are the only elements required to get off the ground with JSON-AI. However, we’re interested in making a <em>custom</em> approach. So, let’s make this syntax a file, and introduce our own changes.</p>
</section>
<section id="3)-Build-your-own-splitter-module">
<h3>3) Build your own splitter module<a class="headerlink" href="#3)-Build-your-own-splitter-module" title="Permalink to this heading"></a></h3>
<p>For Lightwood, the goal of a splitter is to intake an initial dataset (pre-processed ideally, although you can run the pre-processor on each DataFrame within the splitter) and return a dictionary with the keys “train”, “test”, and “dev” (at minimum). Subsequent steps of the pipeline expect the keys “train”, “test”, and “dev”, so it’s important you assign datasets to these as necessary.</p>
<p>We’re going to introduce SMOTE sampling in our splitter. SMOTE allows you to quickly learn an approximation to make extra “samples” that mimic the undersampled class.</p>
<p>We will use the package <code class="docutils literal notranslate"><span class="pre">imblearn</span></code> and <code class="docutils literal notranslate"><span class="pre">scikit-learn</span></code> to quickly create a train/test split and apply SMOTE to our training data only.</p>
<p><strong>NOTE</strong> This is simply an example of things you can do with the splitter; whether SMOTE sampling is ideal for your problem depends on the question you’re trying to answer!</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[5]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">%%writefile</span> MyCustomSplitter.py

<span class="kn">from</span><span class="w"> </span><span class="nn">type_infer.dtype</span><span class="w"> </span><span class="kn">import</span> <span class="n">dtype</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Dict</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">itertools</span><span class="w"> </span><span class="kn">import</span> <span class="n">product</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">lightwood.api.types</span><span class="w"> </span><span class="kn">import</span> <span class="n">TimeseriesSettings</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">lightwood.helpers.log</span><span class="w"> </span><span class="kn">import</span> <span class="n">log</span>


<span class="kn">from</span><span class="w"> </span><span class="nn">imblearn.over_sampling</span><span class="w"> </span><span class="kn">import</span> <span class="n">SMOTE</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.model_selection</span><span class="w"> </span><span class="kn">import</span> <span class="n">train_test_split</span>


<span class="k">def</span><span class="w"> </span><span class="nf">MySplitter</span><span class="p">(</span>
    <span class="n">data</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">target</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">pct_train</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.8</span><span class="p">,</span>
    <span class="n">pct_dev</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span>
    <span class="n">seed</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Custom splitting function</span>


<span class="sd">    :param data: Input data</span>
<span class="sd">    :param target: Name of the target</span>
<span class="sd">    :param pct_train: Percentage of data reserved for training, taken out of full data</span>
<span class="sd">    :param pct_dev: Percentage of data reserved for dev, taken out of train data</span>
<span class="sd">    :param seed: Random seed for reproducibility</span>

<span class="sd">    :returns: A dictionary containing the keys train, test and dev with their respective data frames.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Shuffle the data</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">frac</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">seed</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Split into feature columns + target</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span> <span class="o">!=</span> <span class="n">target</span><span class="p">]</span>  <span class="c1"># .values</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">target</span><span class="p">]</span>  <span class="c1"># .values</span>

    <span class="c1"># Create a train/test split</span>
    <span class="n">X2</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span>
        <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">train_size</span><span class="o">=</span><span class="n">pct_train</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">seed</span><span class="p">,</span> <span class="n">stratify</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="n">target</span><span class="p">]</span>
    <span class="p">)</span>

    <span class="n">X_train</span><span class="p">,</span> <span class="n">X_dev</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_dev</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span>
        <span class="n">X2</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="n">pct_dev</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">seed</span><span class="p">,</span> <span class="n">stratify</span><span class="o">=</span><span class="n">y2</span>
    <span class="p">)</span>

    <span class="c1"># Create a SMOTE model and bump up underbalanced class JUST for train data</span>
    <span class="n">SMOTE_model</span> <span class="o">=</span> <span class="n">SMOTE</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span><span class="n">seed</span><span class="p">)</span>

    <span class="n">Xtrain_mod</span><span class="p">,</span> <span class="n">ytrain_mod</span> <span class="o">=</span> <span class="n">SMOTE_model</span><span class="o">.</span><span class="n">fit_resample</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>

    <span class="n">Xtrain_mod</span><span class="p">[</span><span class="n">target</span><span class="p">]</span> <span class="o">=</span> <span class="n">ytrain_mod</span>
    <span class="n">X_test</span><span class="p">[</span><span class="n">target</span><span class="p">]</span> <span class="o">=</span> <span class="n">y_test</span>
    <span class="n">X_dev</span><span class="p">[</span><span class="n">target</span><span class="p">]</span> <span class="o">=</span> <span class="n">y_dev</span>

    <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;train&quot;</span><span class="p">:</span> <span class="n">Xtrain_mod</span><span class="p">,</span> <span class="s2">&quot;test&quot;</span><span class="p">:</span> <span class="n">X_test</span><span class="p">,</span> <span class="s2">&quot;dev&quot;</span><span class="p">:</span> <span class="n">X_dev</span><span class="p">}</span>
<br/></pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Writing MyCustomSplitter.py
</pre></div></div>
</div>
</section>
</section>
<section id="Place-your-custom-module-in-~/lightwood_modules">
<h2>Place your custom module in <code class="docutils literal notranslate"><span class="pre">~/lightwood_modules</span></code><a class="headerlink" href="#Place-your-custom-module-in-~/lightwood_modules" title="Permalink to this heading"></a></h2>
<p>We automatically search for custom scripts in your <code class="docutils literal notranslate"><span class="pre">~/lightwood_modules</span></code> path. Place your file there. Later, you’ll see when we autogenerate code, that you can change your import location if you choose.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[6]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">lightwood</span><span class="w"> </span><span class="kn">import</span> <span class="n">load_custom_module</span>

<span class="n">load_custom_module</span><span class="p">(</span><span class="s1">&#39;MyCustomSplitter.py&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<section id="4)-Introduce-your-custom-splitter-in-JSON-AI">
<h3>4) Introduce your custom splitter in JSON-AI<a class="headerlink" href="#4)-Introduce-your-custom-splitter-in-JSON-AI" title="Permalink to this heading"></a></h3>
<p>Now let’s introduce our custom splitter. JSON-AI keeps a lightweight syntax but fills in many default modules (like splitting, cleaning).</p>
<p>For the custom cleaner, we’ll work by editing the “splitter” key. We will change properties within it as follows:</p>
<ol class="arabic simple">
<li><p>“module” - place the name of the function. In our case it will be “MyCustomCleaner.cleaner”</p></li>
<li><p>“args” - any keyword argument specific to your cleaner’s internals.</p></li>
</ol>
<p>This will look as follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&quot;splitter&quot;: {
    &quot;module&quot;: &quot;MyCustomSplitter.MySplitter&quot;,
    &quot;args&quot;: {
        &quot;data&quot;: &quot;data&quot;,
        &quot;target&quot;: &quot;$target&quot;,
        &quot;pct_train&quot;: 0.8,
        &quot;pct_dev&quot;: 0.1,
        &quot;seed&quot;: 1
    }
},
</pre></div>
</div>
</section>
<section id="5)-Generate-Python-code-representing-your-ML-pipeline">
<h3>5) Generate Python code representing your ML pipeline<a class="headerlink" href="#5)-Generate-Python-code-representing-your-ML-pipeline" title="Permalink to this heading"></a></h3>
<p>Now we’re ready to load up our custom JSON-AI and generate the predictor code!</p>
<p>We can do this by first reading in our custom json-syntax, and then calling the function <code class="docutils literal notranslate"><span class="pre">code_from_json_ai</span></code>.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[7]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">json_ai</span><span class="o">.</span><span class="n">splitter</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;module&quot;</span><span class="p">:</span> <span class="s2">&quot;MyCustomSplitter.MySplitter&quot;</span><span class="p">,</span>
        <span class="s2">&quot;args&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s2">&quot;data&quot;</span><span class="p">:</span> <span class="s2">&quot;data&quot;</span><span class="p">,</span>
            <span class="s2">&quot;target&quot;</span><span class="p">:</span> <span class="s2">&quot;$target&quot;</span><span class="p">,</span>
            <span class="s2">&quot;pct_train&quot;</span><span class="p">:</span> <span class="mf">0.8</span><span class="p">,</span>
            <span class="s2">&quot;pct_dev&quot;</span><span class="p">:</span> <span class="mf">0.1</span><span class="p">,</span>
            <span class="s2">&quot;seed&quot;</span><span class="p">:</span> <span class="mi">1</span>
        <span class="p">}</span>
    <span class="p">}</span>

<span class="c1">#Generate python code that fills in your pipeline</span>
<span class="n">code</span> <span class="o">=</span> <span class="n">code_from_json_ai</span><span class="p">(</span><span class="n">json_ai</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">code</span><span class="p">)</span>

<span class="c1"># Save code to a file (Optional)</span>
<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;custom_splitter_pipeline.py&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
    <span class="n">fp</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">code</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
import lightwood
from lightwood import __version__ as lightwood_version
from lightwood.analysis import *
from lightwood.api import *
from lightwood.data import *
from lightwood.encoder import *
from lightwood.ensemble import *
from lightwood.helpers.device import *
from lightwood.helpers.general import *
from lightwood.helpers.ts import *
from lightwood.helpers.log import *
from lightwood.helpers.numeric import *
from lightwood.helpers.parallelism import *
from lightwood.helpers.seed import *
from lightwood.helpers.text import *
from lightwood.helpers.torch import *
from lightwood.mixer import *

from dataprep_ml.insights import statistical_analysis
from dataprep_ml.cleaners import cleaner
from dataprep_ml.splitters import splitter
from dataprep_ml.imputers import *

from mindsdb_evaluator import evaluate_accuracies
from mindsdb_evaluator.accuracy import __all__ as mdb_eval_accuracy_metrics

import pandas as pd
from typing import Dict, List, Union, Optional
import os
from types import ModuleType
import importlib.machinery
import sys
import time


for import_dir in [
    os.path.join(
        os.path.expanduser(&#34;~/lightwood_modules&#34;), lightwood_version.replace(&#34;.&#34;, &#34;_&#34;)
    ),
    os.path.join(&#34;/etc/lightwood_modules&#34;, lightwood_version.replace(&#34;.&#34;, &#34;_&#34;)),
]:
    if os.path.exists(import_dir) and os.access(import_dir, os.R_OK):
        for file_name in list(os.walk(import_dir))[0][2]:
            if file_name[-3:] != &#34;.py&#34;:
                continue
            mod_name = file_name[:-3]
            loader = importlib.machinery.SourceFileLoader(
                mod_name, os.path.join(import_dir, file_name)
            )
            module = ModuleType(loader.name)
            loader.exec_module(module)
            sys.modules[mod_name] = module
            exec(f&#34;import {mod_name}&#34;)


class Predictor(PredictorInterface):
    target: str
    mixers: List[BaseMixer]
    encoders: Dict[str, BaseEncoder]
    ensemble: BaseEnsemble
    mode: str

    def __init__(self):
        seed(1)
        self.target = &#34;Class&#34;
        self.mode = &#34;inactive&#34;
        self.problem_definition = ProblemDefinition.from_dict(
            {
                &#34;target&#34;: &#34;Class&#34;,
                &#34;pct_invalid&#34;: 2,
                &#34;unbias_target&#34;: True,
                &#34;seconds_per_mixer&#34;: 42768.0,
                &#34;seconds_per_encoder&#34;: None,
                &#34;expected_additional_time&#34;: 68.71613359451294,
                &#34;time_aim&#34;: 259200,
                &#34;target_weights&#34;: None,
                &#34;positive_domain&#34;: False,
                &#34;timeseries_settings&#34;: {
                    &#34;is_timeseries&#34;: False,
                    &#34;order_by&#34;: None,
                    &#34;window&#34;: None,
                    &#34;group_by&#34;: None,
                    &#34;use_previous_target&#34;: True,
                    &#34;horizon&#34;: None,
                    &#34;historical_columns&#34;: None,
                    &#34;target_type&#34;: &#34;&#34;,
                    &#34;allow_incomplete_history&#34;: True,
                    &#34;eval_incomplete&#34;: False,
                    &#34;interval_periods&#34;: [],
                },
                &#34;anomaly_detection&#34;: False,
                &#34;use_default_analysis&#34;: True,
                &#34;embedding_only&#34;: False,
                &#34;dtype_dict&#34;: {},
                &#34;ignore_features&#34;: [],
                &#34;fit_on_all&#34;: True,
                &#34;strict_mode&#34;: True,
                &#34;seed_nr&#34;: 1,
            }
        )
        self.accuracy_functions = [&#34;balanced_accuracy_score&#34;]
        self.identifiers = {}
        self.dtype_dict = {
            &#34;Time&#34;: &#34;integer&#34;,
            &#34;V1&#34;: &#34;float&#34;,
            &#34;V2&#34;: &#34;float&#34;,
            &#34;V3&#34;: &#34;float&#34;,
            &#34;V4&#34;: &#34;float&#34;,
            &#34;V5&#34;: &#34;float&#34;,
            &#34;V6&#34;: &#34;float&#34;,
            &#34;V7&#34;: &#34;float&#34;,
            &#34;V8&#34;: &#34;float&#34;,
            &#34;V9&#34;: &#34;float&#34;,
            &#34;V10&#34;: &#34;float&#34;,
            &#34;V11&#34;: &#34;float&#34;,
            &#34;V12&#34;: &#34;float&#34;,
            &#34;V13&#34;: &#34;float&#34;,
            &#34;V14&#34;: &#34;float&#34;,
            &#34;V15&#34;: &#34;float&#34;,
            &#34;V16&#34;: &#34;float&#34;,
            &#34;V17&#34;: &#34;float&#34;,
            &#34;V18&#34;: &#34;float&#34;,
            &#34;V19&#34;: &#34;float&#34;,
            &#34;V20&#34;: &#34;float&#34;,
            &#34;V21&#34;: &#34;float&#34;,
            &#34;V22&#34;: &#34;float&#34;,
            &#34;V23&#34;: &#34;float&#34;,
            &#34;V24&#34;: &#34;float&#34;,
            &#34;V25&#34;: &#34;float&#34;,
            &#34;V26&#34;: &#34;float&#34;,
            &#34;V27&#34;: &#34;float&#34;,
            &#34;V28&#34;: &#34;float&#34;,
            &#34;Amount&#34;: &#34;float&#34;,
            &#34;Class&#34;: &#34;binary&#34;,
        }
        self.lightwood_version = &#34;25.3.3.2&#34;
        self.pred_args = PredictionArguments()

        # Any feature-column dependencies
        self.dependencies = {
            &#34;Class&#34;: [],
            &#34;Time&#34;: [],
            &#34;V1&#34;: [],
            &#34;V2&#34;: [],
            &#34;V3&#34;: [],
            &#34;V4&#34;: [],
            &#34;V5&#34;: [],
            &#34;V6&#34;: [],
            &#34;V7&#34;: [],
            &#34;V8&#34;: [],
            &#34;V9&#34;: [],
            &#34;V10&#34;: [],
            &#34;V11&#34;: [],
            &#34;V12&#34;: [],
            &#34;V13&#34;: [],
            &#34;V14&#34;: [],
            &#34;V15&#34;: [],
            &#34;V16&#34;: [],
            &#34;V17&#34;: [],
            &#34;V18&#34;: [],
            &#34;V19&#34;: [],
            &#34;V20&#34;: [],
            &#34;V21&#34;: [],
            &#34;V22&#34;: [],
            &#34;V23&#34;: [],
            &#34;V24&#34;: [],
            &#34;V25&#34;: [],
            &#34;V26&#34;: [],
            &#34;V27&#34;: [],
            &#34;V28&#34;: [],
            &#34;Amount&#34;: [],
        }

        self.input_cols = [
            &#34;Time&#34;,
            &#34;V1&#34;,
            &#34;V2&#34;,
            &#34;V3&#34;,
            &#34;V4&#34;,
            &#34;V5&#34;,
            &#34;V6&#34;,
            &#34;V7&#34;,
            &#34;V8&#34;,
            &#34;V9&#34;,
            &#34;V10&#34;,
            &#34;V11&#34;,
            &#34;V12&#34;,
            &#34;V13&#34;,
            &#34;V14&#34;,
            &#34;V15&#34;,
            &#34;V16&#34;,
            &#34;V17&#34;,
            &#34;V18&#34;,
            &#34;V19&#34;,
            &#34;V20&#34;,
            &#34;V21&#34;,
            &#34;V22&#34;,
            &#34;V23&#34;,
            &#34;V24&#34;,
            &#34;V25&#34;,
            &#34;V26&#34;,
            &#34;V27&#34;,
            &#34;V28&#34;,
            &#34;Amount&#34;,
        ]

        # Initial stats analysis
        self.statistical_analysis = None
        self.ts_analysis = None
        self.runtime_log = dict()
        self.global_insights = dict()

        # Feature cache
        self.feature_cache = dict()

    @timed_predictor
    def analyze_data(self, data: pd.DataFrame) -&gt; None:
        # Perform a statistical analysis on the unprocessed data

        self.statistical_analysis = statistical_analysis(
            data, self.dtype_dict, self.problem_definition.to_dict(), {}
        )

        # Instantiate post-training evaluation
        self.analysis_blocks = [
            ICP(fixed_significance=None, confidence_normalizer=False, deps=[]),
            ConfStats(deps=[&#34;ICP&#34;]),
            AccStats(deps=[&#34;ICP&#34;]),
            PermutationFeatureImportance(deps=[&#34;AccStats&#34;]),
        ]

    @timed_predictor
    def preprocess(self, data: pd.DataFrame) -&gt; pd.DataFrame:
        # Preprocess and clean data

        log.info(&#34;Cleaning the data&#34;)
        self.imputers = {}
        data = cleaner(
            data=data,
            pct_invalid=self.problem_definition.pct_invalid,
            identifiers=self.identifiers,
            dtype_dict=self.dtype_dict,
            target=self.target,
            mode=self.mode,
            imputers=self.imputers,
            timeseries_settings=self.problem_definition.timeseries_settings.to_dict(),
            anomaly_detection=self.problem_definition.anomaly_detection,
        )

        # Time-series blocks

        return data

    @timed_predictor
    def split(self, data: pd.DataFrame) -&gt; Dict[str, pd.DataFrame]:
        # Split the data into training/testing splits

        log.info(&#34;Splitting the data into train/test&#34;)
        train_test_data = MyCustomSplitter.MySplitter(
            data=data, pct_train=0.8, pct_dev=0.1, seed=1, target=self.target
        )

        return train_test_data

    @timed_predictor
    def prepare(self, data: Dict[str, pd.DataFrame]) -&gt; None:
        # Prepare encoders to featurize data

        self.mode = &#34;train&#34;

        if self.statistical_analysis is None:
            raise Exception(&#34;Please run analyze_data first&#34;)

        # Column to encoder mapping
        self.encoders = {
            &#34;Class&#34;: BinaryEncoder(
                is_target=True, target_weights=self.statistical_analysis.target_weights
            ),
            &#34;Time&#34;: NumericEncoder(),
            &#34;V1&#34;: NumericEncoder(),
            &#34;V2&#34;: NumericEncoder(),
            &#34;V3&#34;: NumericEncoder(),
            &#34;V4&#34;: NumericEncoder(),
            &#34;V5&#34;: NumericEncoder(),
            &#34;V6&#34;: NumericEncoder(),
            &#34;V7&#34;: NumericEncoder(),
            &#34;V8&#34;: NumericEncoder(),
            &#34;V9&#34;: NumericEncoder(),
            &#34;V10&#34;: NumericEncoder(),
            &#34;V11&#34;: NumericEncoder(),
            &#34;V12&#34;: NumericEncoder(),
            &#34;V13&#34;: NumericEncoder(),
            &#34;V14&#34;: NumericEncoder(),
            &#34;V15&#34;: NumericEncoder(),
            &#34;V16&#34;: NumericEncoder(),
            &#34;V17&#34;: NumericEncoder(),
            &#34;V18&#34;: NumericEncoder(),
            &#34;V19&#34;: NumericEncoder(),
            &#34;V20&#34;: NumericEncoder(),
            &#34;V21&#34;: NumericEncoder(),
            &#34;V22&#34;: NumericEncoder(),
            &#34;V23&#34;: NumericEncoder(),
            &#34;V24&#34;: NumericEncoder(),
            &#34;V25&#34;: NumericEncoder(),
            &#34;V26&#34;: NumericEncoder(),
            &#34;V27&#34;: NumericEncoder(),
            &#34;V28&#34;: NumericEncoder(),
            &#34;Amount&#34;: NumericEncoder(),
        }

        # Prepare the training + dev data
        concatenated_train_dev = pd.concat([data[&#34;train&#34;], data[&#34;dev&#34;]])

        prepped_encoders = {}

        # Prepare input encoders
        parallel_encoding = parallel_encoding_check(data[&#34;train&#34;], self.encoders)

        if parallel_encoding:
            log.debug(&#34;Preparing in parallel...&#34;)
            for col_name, encoder in self.encoders.items():
                if col_name != self.target and not encoder.is_trainable_encoder:
                    prepped_encoders[col_name] = (
                        encoder,
                        concatenated_train_dev[col_name],
                        &#34;prepare&#34;,
                    )
            prepped_encoders = mut_method_call(prepped_encoders)

        else:
            log.debug(&#34;Preparing sequentially...&#34;)
            for col_name, encoder in self.encoders.items():
                if col_name != self.target and not encoder.is_trainable_encoder:
                    log.debug(f&#34;Preparing encoder for {col_name}...&#34;)
                    encoder.prepare(concatenated_train_dev[col_name])
                    prepped_encoders[col_name] = encoder

        # Store encoders
        for col_name, encoder in prepped_encoders.items():
            self.encoders[col_name] = encoder

        # Prepare the target
        if self.target not in prepped_encoders:
            if self.encoders[self.target].is_trainable_encoder:
                self.encoders[self.target].prepare(
                    data[&#34;train&#34;][self.target], data[&#34;dev&#34;][self.target]
                )
            else:
                self.encoders[self.target].prepare(
                    pd.concat([data[&#34;train&#34;], data[&#34;dev&#34;]])[self.target]
                )

        # Prepare any non-target encoders that are learned
        for col_name, encoder in self.encoders.items():
            if col_name != self.target and encoder.is_trainable_encoder:
                priming_data = pd.concat([data[&#34;train&#34;], data[&#34;dev&#34;]])
                kwargs = {}
                if self.dependencies[col_name]:
                    kwargs[&#34;dependency_data&#34;] = {}
                    for col in self.dependencies[col_name]:
                        kwargs[&#34;dependency_data&#34;][col] = {
                            &#34;original_type&#34;: self.dtype_dict[col],
                            &#34;data&#34;: priming_data[col],
                        }

                # If an encoder representation requires the target, provide priming data
                if hasattr(encoder, &#34;uses_target&#34;):
                    kwargs[&#34;encoded_target_values&#34;] = self.encoders[self.target].encode(
                        priming_data[self.target]
                    )

                encoder.prepare(
                    data[&#34;train&#34;][col_name], data[&#34;dev&#34;][col_name], **kwargs
                )

    @timed_predictor
    def featurize(self, split_data: Dict[str, pd.DataFrame]):
        # Featurize data into numerical representations for models

        log.info(&#34;Featurizing the data&#34;)

        tss = self.problem_definition.timeseries_settings

        feature_data = dict()
        for key, data in split_data.items():
            if key != &#34;stratified_on&#34;:

                # compute and store two splits - full and filtered (useful for time series post-train analysis)
                if key not in self.feature_cache:
                    featurized_split = EncodedDs(self.encoders, data, self.target)
                    filtered_subset = EncodedDs(
                        self.encoders, filter_ts(data, tss), self.target
                    )

                    for k, s in zip(
                        (key, f&#34;{key}_filtered&#34;), (featurized_split, filtered_subset)
                    ):
                        self.feature_cache[k] = s

                for k in (key, f&#34;{key}_filtered&#34;):
                    feature_data[k] = self.feature_cache[k]

        return feature_data

    @timed_predictor
    def fit(self, enc_data: Dict[str, pd.DataFrame]) -&gt; None:
        # Fit predictors to estimate target

        self.mode = &#34;train&#34;

        # --------------- #
        # Extract data
        # --------------- #
        # Extract the featurized data into train/dev/test
        encoded_train_data = enc_data[&#34;train&#34;]
        encoded_dev_data = enc_data[&#34;dev&#34;]
        encoded_test_data = enc_data[&#34;test_filtered&#34;]

        log.info(&#34;Training the mixers&#34;)

        # --------------- #
        # Fit Models
        # --------------- #
        # Assign list of mixers
        self.mixers = [
            Neural(
                fit_on_dev=True,
                search_hyperparameters=True,
                net=&#34;DefaultNet&#34;,
                stop_after=self.problem_definition.seconds_per_mixer,
                target=self.target,
                dtype_dict=self.dtype_dict,
                target_encoder=self.encoders[self.target],
            ),
            XGBoostMixer(
                fit_on_dev=True,
                use_optuna=True,
                stop_after=self.problem_definition.seconds_per_mixer,
                target=self.target,
                dtype_dict=self.dtype_dict,
                input_cols=self.input_cols,
                target_encoder=self.encoders[self.target],
            ),
            Regression(
                stop_after=self.problem_definition.seconds_per_mixer,
                target=self.target,
                dtype_dict=self.dtype_dict,
                target_encoder=self.encoders[self.target],
            ),
            RandomForest(
                fit_on_dev=True,
                stop_after=self.problem_definition.seconds_per_mixer,
                target=self.target,
                dtype_dict=self.dtype_dict,
                target_encoder=self.encoders[self.target],
            ),
        ]

        # Train mixers
        trained_mixers = []
        for mixer in self.mixers:
            try:
                if mixer.trains_once:
                    self.fit_mixer(
                        mixer,
                        ConcatedEncodedDs([encoded_train_data, encoded_dev_data]),
                        encoded_test_data,
                    )
                else:
                    self.fit_mixer(mixer, encoded_train_data, encoded_dev_data)
                trained_mixers.append(mixer)
            except Exception as e:
                log.warning(f&#34;Exception: {e} when training mixer: {mixer}&#34;)
                if True and mixer.stable:
                    raise e

        # Update mixers to trained versions
        if not trained_mixers:
            raise Exception(
                &#34;No mixers could be trained! Please verify your problem definition or JsonAI model representation.&#34;
            )
        self.mixers = trained_mixers

        # --------------- #
        # Create Ensembles
        # --------------- #
        log.info(&#34;Ensembling the mixer&#34;)
        # Create an ensemble of mixers to identify best performing model
        # Dirty hack
        self.ensemble = BestOf(
            data=encoded_test_data,
            fit=True,
            ts_analysis=None,
            target=self.target,
            mixers=self.mixers,
            args=self.pred_args,
            accuracy_functions=self.accuracy_functions,
        )
        self.supports_proba = self.ensemble.supports_proba

    @timed_predictor
    def fit_mixer(self, mixer, encoded_train_data, encoded_dev_data) -&gt; None:
        mixer.fit(encoded_train_data, encoded_dev_data)

    @timed_predictor
    def analyze_ensemble(self, enc_data: Dict[str, pd.DataFrame]) -&gt; None:
        # Evaluate quality of fit for the ensemble of mixers

        # --------------- #
        # Extract data
        # --------------- #
        # Extract the featurized data into train/dev/test
        encoded_train_data = enc_data[&#34;train&#34;]
        encoded_dev_data = enc_data[&#34;dev&#34;]
        encoded_test_data = enc_data[&#34;test&#34;]

        # --------------- #
        # Analyze Ensembles
        # --------------- #
        log.info(&#34;Analyzing the ensemble of mixers&#34;)
        self.model_analysis, self.runtime_analyzer = model_analyzer(
            data=encoded_test_data,
            train_data=encoded_train_data,
            ts_analysis=None,
            stats_info=self.statistical_analysis,
            pdef=self.problem_definition,
            accuracy_functions=self.accuracy_functions,
            predictor=self.ensemble,
            target=self.target,
            dtype_dict=self.dtype_dict,
            analysis_blocks=self.analysis_blocks,
        )

    @timed_predictor
    def learn(self, data: pd.DataFrame) -&gt; None:
        if self.problem_definition.ignore_features:
            log.info(f&#34;Dropping features: {self.problem_definition.ignore_features}&#34;)
            data = data.drop(
                columns=self.problem_definition.ignore_features, errors=&#34;ignore&#34;
            )

        self.mode = &#34;train&#34;
        n_phases = 8 if self.problem_definition.fit_on_all else 7

        # Perform stats analysis
        log.info(f&#34;[Learn phase 1/{n_phases}] - Statistical analysis&#34;)
        self.analyze_data(data)

        # Pre-process the data
        log.info(f&#34;[Learn phase 2/{n_phases}] - Data preprocessing&#34;)
        data = self.preprocess(data)

        # Create train/test (dev) split
        log.info(f&#34;[Learn phase 3/{n_phases}] - Data splitting&#34;)
        train_dev_test = self.split(data)

        # Prepare encoders
        log.info(f&#34;[Learn phase 4/{n_phases}] - Preparing encoders&#34;)
        self.prepare(train_dev_test)

        # Create feature vectors from data
        log.info(f&#34;[Learn phase 5/{n_phases}] - Feature generation&#34;)
        enc_train_test = self.featurize(train_dev_test)

        # Prepare mixers
        log.info(f&#34;[Learn phase 6/{n_phases}] - Mixer training&#34;)
        if not self.problem_definition.embedding_only:
            self.fit(enc_train_test)
        else:
            self.mixers = []
            self.ensemble = Embedder(
                self.target, mixers=list(), data=enc_train_test[&#34;train&#34;]
            )
            self.supports_proba = self.ensemble.supports_proba

        # Analyze the ensemble
        log.info(f&#34;[Learn phase 7/{n_phases}] - Ensemble analysis&#34;)
        self.analyze_ensemble(enc_train_test)

        # ------------------------ #
        # Enable model partial fit AFTER it is trained and evaluated for performance with the appropriate train/dev/test splits.
        # This assumes the predictor could continuously evolve, hence including reserved testing data may improve predictions.
        # SET `json_ai.problem_definition.fit_on_all=False` TO TURN THIS BLOCK OFF.

        # Update the mixers with partial fit
        if self.problem_definition.fit_on_all and all(
            [not m.trains_once for m in self.mixers]
        ):
            log.info(f&#34;[Learn phase 8/{n_phases}] - Adjustment on validation requested&#34;)
            self.adjust(
                enc_train_test[&#34;test&#34;].data_frame,
                ConcatedEncodedDs(
                    [enc_train_test[&#34;train&#34;], enc_train_test[&#34;dev&#34;]]
                ).data_frame,
                adjust_args={&#34;learn_call&#34;: True},
            )

        self.feature_cache = (
            dict()
        )  # empty feature cache to avoid large predictor objects

    @timed_predictor
    def adjust(
        self,
        train_data: Union[EncodedDs, ConcatedEncodedDs, pd.DataFrame],
        dev_data: Optional[Union[EncodedDs, ConcatedEncodedDs, pd.DataFrame]] = None,
        adjust_args: Optional[dict] = None,
    ) -&gt; None:
        # Update mixers with new information

        self.mode = &#34;train&#34;

        # --------------- #
        # Prepare data
        # --------------- #
        if dev_data is None:
            data = train_data
            split = splitter(
                data=data,
                pct_train=0.8,
                pct_dev=0.2,
                pct_test=0,
                tss=self.problem_definition.timeseries_settings.to_dict(),
                seed=self.problem_definition.seed_nr,
                target=self.target,
                dtype_dict=self.dtype_dict,
            )
            train_data = split[&#34;train&#34;]
            dev_data = split[&#34;dev&#34;]

        if adjust_args is None or not adjust_args.get(&#34;learn_call&#34;):
            train_data = self.preprocess(train_data)
            dev_data = self.preprocess(dev_data)

        dev_data = EncodedDs(self.encoders, dev_data, self.target)
        train_data = EncodedDs(self.encoders, train_data, self.target)

        # --------------- #
        # Update/Adjust Mixers
        # --------------- #
        log.info(&#34;Updating the mixers&#34;)

        for mixer in self.mixers:
            mixer.partial_fit(train_data, dev_data, adjust_args)

    @timed_predictor
    def predict(self, data: pd.DataFrame, args: Dict = {}) -&gt; pd.DataFrame:

        self.mode = &#34;predict&#34;
        n_phases = 3 if self.pred_args.all_mixers else 4

        if len(data) == 0:
            raise Exception(
                &#34;Empty input, aborting prediction. Please try again with some input data.&#34;
            )

        self.pred_args = PredictionArguments.from_dict(args)

        log.info(f&#34;[Predict phase 1/{n_phases}] - Data preprocessing&#34;)
        if self.problem_definition.ignore_features:
            log.info(f&#34;Dropping features: {self.problem_definition.ignore_features}&#34;)
            data = data.drop(
                columns=self.problem_definition.ignore_features, errors=&#34;ignore&#34;
            )
        for col in self.input_cols:
            if col not in data.columns:
                data[col] = [None] * len(data)

        # Pre-process the data
        data = self.preprocess(data)

        # Featurize the data
        log.info(f&#34;[Predict phase 2/{n_phases}] - Feature generation&#34;)
        encoded_ds = self.featurize({&#34;predict_data&#34;: data})[&#34;predict_data&#34;]
        encoded_data = encoded_ds.get_encoded_data(include_target=False)

        log.info(f&#34;[Predict phase 3/{n_phases}] - Calling ensemble&#34;)

        @timed
        def _timed_call(encoded_ds):
            if self.pred_args.return_embedding:
                embedder = Embedder(self.target, mixers=list(), data=encoded_ds)
                df = embedder(encoded_ds, args=self.pred_args)
            else:
                df = self.ensemble(encoded_ds, args=self.pred_args)
            return df

        df = _timed_call(encoded_ds)

        if not (
            any(
                [
                    self.pred_args.all_mixers,
                    self.pred_args.return_embedding,
                    self.problem_definition.embedding_only,
                ]
            )
        ):
            log.info(f&#34;[Predict phase 4/{n_phases}] - Analyzing output&#34;)
            df, global_insights = explain(
                data=data,
                encoded_data=encoded_data,
                predictions=df,
                ts_analysis=None,
                problem_definition=self.problem_definition,
                stat_analysis=self.statistical_analysis,
                runtime_analysis=self.runtime_analyzer,
                target_name=self.target,
                target_dtype=self.dtype_dict[self.target],
                explainer_blocks=self.analysis_blocks,
                pred_args=self.pred_args,
            )
            self.global_insights = {**self.global_insights, **global_insights}

        self.feature_cache = (
            dict()
        )  # empty feature cache to avoid large predictor objects

        return df

    def test(
        self,
        data: pd.DataFrame,
        metrics: list,
        args: Dict[str, object] = {},
        strict: bool = False,
    ) -&gt; pd.DataFrame:

        preds = self.predict(data, args)
        preds = preds.rename(columns={&#34;prediction&#34;: self.target})
        filtered = []

        # filter metrics if not supported
        for metric in metrics:
            # metric should be one of: an actual function, registered in the model class, or supported by the evaluator
            if not (
                callable(metric)
                or metric in self.accuracy_functions
                or metric in mdb_eval_accuracy_metrics
            ):
                if strict:
                    raise Exception(f&#34;Invalid metric: {metric}&#34;)
                else:
                    log.warning(f&#34;Invalid metric: {metric}. Skipping...&#34;)
            else:
                filtered.append(metric)

        metrics = filtered
        try:
            labels = self.model_analysis.histograms[self.target][&#34;x&#34;]
        except:
            if strict:
                raise Exception(&#34;Label histogram not found&#34;)
            else:
                label_map = (
                    None  # some accuracy functions will crash without this, be mindful
                )
        scores = evaluate_accuracies(
            data,
            preds[self.target],
            self.target,
            metrics,
            ts_analysis=self.ts_analysis,
            labels=labels,
        )

        # TODO: remove once mdb_eval returns an actual list
        scores = {k: [v] for k, v in scores.items() if not isinstance(v, list)}

        return pd.DataFrame.from_records(
            scores
        )  # TODO: add logic to disaggregate per-mixer

</pre></div></div>
</div>
<p>As you can see, an end-to-end pipeline of our entire ML procedure has been generating. There are several abstracted functions to enable transparency as to what processes your data goes through in order to build these models.</p>
<p>The key steps of the pipeline are as follows:</p>
<ol class="arabic simple">
<li><p>Run a <strong>statistical analysis</strong> with <code class="docutils literal notranslate"><span class="pre">analyze_data</span></code></p></li>
<li><p>Clean your data with <code class="docutils literal notranslate"><span class="pre">preprocess</span></code></p></li>
<li><p>Make a training/dev/testing split with <code class="docutils literal notranslate"><span class="pre">split</span></code></p></li>
<li><p>Prepare your feature-engineering pipelines with <code class="docutils literal notranslate"><span class="pre">prepare</span></code></p></li>
<li><p>Create your features with <code class="docutils literal notranslate"><span class="pre">featurize</span></code></p></li>
<li><p>Fit your predictor models with <code class="docutils literal notranslate"><span class="pre">fit</span></code></p></li>
</ol>
<p>You can customize this further if necessary, but you have all the steps necessary to train a model!</p>
<p>We recommend familiarizing with these steps by calling the above commands, ideally in order. Some commands (namely <code class="docutils literal notranslate"><span class="pre">prepare</span></code>, <code class="docutils literal notranslate"><span class="pre">featurize</span></code>, and <code class="docutils literal notranslate"><span class="pre">fit</span></code>) do depend on other steps.</p>
<p>If you want to omit the individual steps, we recommend your simply call the <code class="docutils literal notranslate"><span class="pre">learn</span></code> method, which compiles all the necessary steps implemented to give your fully trained predictive models starting with unprocessed data!</p>
</section>
<section id="6)-Call-python-to-run-your-code-and-see-your-preprocessed-outputs">
<h3>6) Call python to run your code and see your preprocessed outputs<a class="headerlink" href="#6)-Call-python-to-run-your-code-and-see-your-preprocessed-outputs" title="Permalink to this heading"></a></h3>
<p>Once we have code, we can turn this into a python object by calling <code class="docutils literal notranslate"><span class="pre">predictor_from_code</span></code>. This instantiates the <code class="docutils literal notranslate"><span class="pre">PredictorInterface</span></code> object.</p>
<p>This predictor object can be then used to run your pipeline.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[8]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Turn the code above into a predictor object</span>
<span class="n">predictor</span> <span class="o">=</span> <span class="n">predictor_from_code</span><span class="p">(</span><span class="n">code</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[9]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Pre-process the data</span>
<span class="n">cleaned_data</span> <span class="o">=</span> <span class="n">predictor</span><span class="o">.</span><span class="n">preprocess</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="n">train_test_data</span> <span class="o">=</span> <span class="n">predictor</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">cleaned_data</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area stderr docutils container">
<div class="highlight"><pre>
<span class="ansi-green-fg">INFO:dataprep_ml-2968:Cleaning the data</span>
<span class="ansi-white-fg">DEBUG:lightwood-2968: `preprocess` runtime: 18.55 seconds</span>
<span class="ansi-green-fg">INFO:dataprep_ml-2968:Splitting the data into train/test</span>
<span class="ansi-white-fg">DEBUG:lightwood-2968: `split` runtime: 1.72 seconds</span>
</pre></div></div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[10]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;font.size&#39;</span><span class="p">]</span><span class="o">=</span><span class="mi">15</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">18</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>

<span class="n">ax</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">train_test_data</span><span class="p">[</span><span class="s2">&quot;train&quot;</span><span class="p">][</span><span class="s1">&#39;Class&#39;</span><span class="p">],</span> <span class="n">bins</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">,</span> <span class="mf">1.1</span><span class="p">],</span> <span class="n">log</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Log Counts&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xticklabels</span><span class="p">([</span><span class="s2">&quot;0&quot;</span><span class="p">,</span> <span class="s2">&quot;1&quot;</span><span class="p">])</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Class&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Train:</span><span class="se">\n</span><span class="s2">Distribution of Classes&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mf">1e6</span><span class="p">])</span>

<span class="n">ax</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">train_test_data</span><span class="p">[</span><span class="s2">&quot;dev&quot;</span><span class="p">][</span><span class="s1">&#39;Class&#39;</span><span class="p">],</span> <span class="n">bins</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">,</span> <span class="mf">1.1</span><span class="p">],</span> <span class="n">log</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Log Counts&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xticklabels</span><span class="p">([</span><span class="s2">&quot;0&quot;</span><span class="p">,</span> <span class="s2">&quot;1&quot;</span><span class="p">])</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Class&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Dev:</span><span class="se">\n</span><span class="s2">Distribution of Classes&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mf">1e6</span><span class="p">])</span>


<span class="n">ax</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">train_test_data</span><span class="p">[</span><span class="s2">&quot;test&quot;</span><span class="p">][</span><span class="s1">&#39;Class&#39;</span><span class="p">],</span> <span class="n">bins</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">,</span> <span class="mf">1.1</span><span class="p">],</span> <span class="n">log</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Log Counts&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xticklabels</span><span class="p">([</span><span class="s2">&quot;0&quot;</span><span class="p">,</span> <span class="s2">&quot;1&quot;</span><span class="p">])</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Class&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Test:</span><span class="se">\n</span><span class="s2">Distribution of Classes&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mf">1e6</span><span class="p">])</span>

<span class="n">f</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../../_images/tutorials_custom_splitter_custom_splitter_21_0.png" src="../../_images/tutorials_custom_splitter_custom_splitter_21_0.png" />
</div>
</div>
<p>As you can see, our splitter has greatly increased the representation of the minority class within the training data, but not so for the testing or dev data.</p>
<p>We hope this tutorial was informative on how to introduce a <strong>custom splitter method</strong> to your datasets! For more customization tutorials, please check our <a class="reference external" href="https://lightwood.io/tutorials.html">documentation</a>.</p>
<p>If you want to download the Jupyter-notebook version of this tutorial, check out the source github location found here: <code class="docutils literal notranslate"><span class="pre">lightwood/docssrc/source/tutorials/custom_splitter</span></code>.</p>
</section>
</section>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2017-2025, MindsDB.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>