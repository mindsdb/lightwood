

<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Encoders &mdash; lightwood 24.5.2.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css" />
      <link rel="stylesheet" type="text/css" href="_static/graphviz.css" />
      <link rel="stylesheet" type="text/css" href="_static/custom.css" />

  
      <script src="_static/jquery.js"></script>
      <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
      <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
      <script src="_static/doctools.js"></script>
      <script src="_static/sphinx_highlight.js"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
      <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
      <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Mixers" href="mixer.html" />
    <link rel="prev" title="Data" href="data.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: white" >

          
          
          <a href="index.html">
            
              <img src="_static/mindsdblogo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="tutorials.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">Tutorials</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="api.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">API</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="data.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">Data</span></code></a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">Encoders</span></code></a><ul>
<li class="toctree-l2"><a class="reference internal" href="#encoder.ArrayEncoder"><code class="docutils literal notranslate"><span class="pre">ArrayEncoder</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#encoder.ArrayEncoder.decode"><code class="docutils literal notranslate"><span class="pre">ArrayEncoder.decode()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#encoder.ArrayEncoder.encode"><code class="docutils literal notranslate"><span class="pre">ArrayEncoder.encode()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#encoder.ArrayEncoder.prepare"><code class="docutils literal notranslate"><span class="pre">ArrayEncoder.prepare()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#encoder.BaseEncoder"><code class="docutils literal notranslate"><span class="pre">BaseEncoder</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#encoder.BaseEncoder.decode"><code class="docutils literal notranslate"><span class="pre">BaseEncoder.decode()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#encoder.BaseEncoder.encode"><code class="docutils literal notranslate"><span class="pre">BaseEncoder.encode()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#encoder.BaseEncoder.prepare"><code class="docutils literal notranslate"><span class="pre">BaseEncoder.prepare()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#encoder.BinaryEncoder"><code class="docutils literal notranslate"><span class="pre">BinaryEncoder</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#encoder.BinaryEncoder.decode"><code class="docutils literal notranslate"><span class="pre">BinaryEncoder.decode()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#encoder.BinaryEncoder.decode_probabilities"><code class="docutils literal notranslate"><span class="pre">BinaryEncoder.decode_probabilities()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#encoder.BinaryEncoder.encode"><code class="docutils literal notranslate"><span class="pre">BinaryEncoder.encode()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#encoder.BinaryEncoder.prepare"><code class="docutils literal notranslate"><span class="pre">BinaryEncoder.prepare()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#encoder.CatArrayEncoder"><code class="docutils literal notranslate"><span class="pre">CatArrayEncoder</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#encoder.CatArrayEncoder.decode"><code class="docutils literal notranslate"><span class="pre">CatArrayEncoder.decode()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#encoder.CatArrayEncoder.prepare"><code class="docutils literal notranslate"><span class="pre">CatArrayEncoder.prepare()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#encoder.CategoricalAutoEncoder"><code class="docutils literal notranslate"><span class="pre">CategoricalAutoEncoder</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#encoder.CategoricalAutoEncoder.decode"><code class="docutils literal notranslate"><span class="pre">CategoricalAutoEncoder.decode()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#encoder.CategoricalAutoEncoder.encode"><code class="docutils literal notranslate"><span class="pre">CategoricalAutoEncoder.encode()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#encoder.CategoricalAutoEncoder.prepare"><code class="docutils literal notranslate"><span class="pre">CategoricalAutoEncoder.prepare()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#encoder.DatetimeEncoder"><code class="docutils literal notranslate"><span class="pre">DatetimeEncoder</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#encoder.DatetimeEncoder.decode"><code class="docutils literal notranslate"><span class="pre">DatetimeEncoder.decode()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#encoder.DatetimeEncoder.encode"><code class="docutils literal notranslate"><span class="pre">DatetimeEncoder.encode()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#encoder.DatetimeEncoder.prepare"><code class="docutils literal notranslate"><span class="pre">DatetimeEncoder.prepare()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#encoder.DatetimeNormalizerEncoder"><code class="docutils literal notranslate"><span class="pre">DatetimeNormalizerEncoder</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#encoder.DatetimeNormalizerEncoder.decode"><code class="docutils literal notranslate"><span class="pre">DatetimeNormalizerEncoder.decode()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#encoder.DatetimeNormalizerEncoder.encode"><code class="docutils literal notranslate"><span class="pre">DatetimeNormalizerEncoder.encode()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#encoder.DatetimeNormalizerEncoder.encode_one"><code class="docutils literal notranslate"><span class="pre">DatetimeNormalizerEncoder.encode_one()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#encoder.DatetimeNormalizerEncoder.prepare"><code class="docutils literal notranslate"><span class="pre">DatetimeNormalizerEncoder.prepare()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#encoder.Img2VecEncoder"><code class="docutils literal notranslate"><span class="pre">Img2VecEncoder</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#encoder.Img2VecEncoder.decode"><code class="docutils literal notranslate"><span class="pre">Img2VecEncoder.decode()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#encoder.Img2VecEncoder.encode"><code class="docutils literal notranslate"><span class="pre">Img2VecEncoder.encode()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#encoder.Img2VecEncoder.prepare"><code class="docutils literal notranslate"><span class="pre">Img2VecEncoder.prepare()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#encoder.Img2VecEncoder.to"><code class="docutils literal notranslate"><span class="pre">Img2VecEncoder.to()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#encoder.MultiHotEncoder"><code class="docutils literal notranslate"><span class="pre">MultiHotEncoder</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#encoder.MultiHotEncoder.decode"><code class="docutils literal notranslate"><span class="pre">MultiHotEncoder.decode()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#encoder.MultiHotEncoder.encode"><code class="docutils literal notranslate"><span class="pre">MultiHotEncoder.encode()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#encoder.MultiHotEncoder.prepare"><code class="docutils literal notranslate"><span class="pre">MultiHotEncoder.prepare()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#encoder.NumArrayEncoder"><code class="docutils literal notranslate"><span class="pre">NumArrayEncoder</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#encoder.NumericEncoder"><code class="docutils literal notranslate"><span class="pre">NumericEncoder</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#encoder.NumericEncoder.decode"><code class="docutils literal notranslate"><span class="pre">NumericEncoder.decode()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#encoder.NumericEncoder.encode"><code class="docutils literal notranslate"><span class="pre">NumericEncoder.encode()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#encoder.NumericEncoder.prepare"><code class="docutils literal notranslate"><span class="pre">NumericEncoder.prepare()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#encoder.OneHotEncoder"><code class="docutils literal notranslate"><span class="pre">OneHotEncoder</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#encoder.OneHotEncoder.decode"><code class="docutils literal notranslate"><span class="pre">OneHotEncoder.decode()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#encoder.OneHotEncoder.decode_probabilities"><code class="docutils literal notranslate"><span class="pre">OneHotEncoder.decode_probabilities()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#encoder.OneHotEncoder.encode"><code class="docutils literal notranslate"><span class="pre">OneHotEncoder.encode()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#encoder.OneHotEncoder.prepare"><code class="docutils literal notranslate"><span class="pre">OneHotEncoder.prepare()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#encoder.PretrainedLangEncoder"><code class="docutils literal notranslate"><span class="pre">PretrainedLangEncoder</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#encoder.PretrainedLangEncoder.decode"><code class="docutils literal notranslate"><span class="pre">PretrainedLangEncoder.decode()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#encoder.PretrainedLangEncoder.encode"><code class="docutils literal notranslate"><span class="pre">PretrainedLangEncoder.encode()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#encoder.PretrainedLangEncoder.is_trainable_encoder"><code class="docutils literal notranslate"><span class="pre">PretrainedLangEncoder.is_trainable_encoder</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#encoder.PretrainedLangEncoder.prepare"><code class="docutils literal notranslate"><span class="pre">PretrainedLangEncoder.prepare()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#encoder.PretrainedLangEncoder.to"><code class="docutils literal notranslate"><span class="pre">PretrainedLangEncoder.to()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#encoder.ShortTextEncoder"><code class="docutils literal notranslate"><span class="pre">ShortTextEncoder</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#encoder.ShortTextEncoder.decode"><code class="docutils literal notranslate"><span class="pre">ShortTextEncoder.decode()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#encoder.ShortTextEncoder.encode"><code class="docutils literal notranslate"><span class="pre">ShortTextEncoder.encode()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#encoder.ShortTextEncoder.prepare"><code class="docutils literal notranslate"><span class="pre">ShortTextEncoder.prepare()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#encoder.SimpleLabelEncoder"><code class="docutils literal notranslate"><span class="pre">SimpleLabelEncoder</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#encoder.SimpleLabelEncoder.decode"><code class="docutils literal notranslate"><span class="pre">SimpleLabelEncoder.decode()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#encoder.SimpleLabelEncoder.encode"><code class="docutils literal notranslate"><span class="pre">SimpleLabelEncoder.encode()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#encoder.SimpleLabelEncoder.prepare"><code class="docutils literal notranslate"><span class="pre">SimpleLabelEncoder.prepare()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#encoder.TimeSeriesEncoder"><code class="docutils literal notranslate"><span class="pre">TimeSeriesEncoder</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#encoder.TimeSeriesEncoder.decode"><code class="docutils literal notranslate"><span class="pre">TimeSeriesEncoder.decode()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#encoder.TimeSeriesEncoder.encode"><code class="docutils literal notranslate"><span class="pre">TimeSeriesEncoder.encode()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#encoder.TsArrayNumericEncoder"><code class="docutils literal notranslate"><span class="pre">TsArrayNumericEncoder</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#encoder.TsArrayNumericEncoder.decode"><code class="docutils literal notranslate"><span class="pre">TsArrayNumericEncoder.decode()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#encoder.TsArrayNumericEncoder.decode_one"><code class="docutils literal notranslate"><span class="pre">TsArrayNumericEncoder.decode_one()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#encoder.TsArrayNumericEncoder.encode"><code class="docutils literal notranslate"><span class="pre">TsArrayNumericEncoder.encode()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#encoder.TsArrayNumericEncoder.prepare"><code class="docutils literal notranslate"><span class="pre">TsArrayNumericEncoder.prepare()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#encoder.TsCatArrayEncoder"><code class="docutils literal notranslate"><span class="pre">TsCatArrayEncoder</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#encoder.TsCatArrayEncoder.decode"><code class="docutils literal notranslate"><span class="pre">TsCatArrayEncoder.decode()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#encoder.TsCatArrayEncoder.decode_one"><code class="docutils literal notranslate"><span class="pre">TsCatArrayEncoder.decode_one()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#encoder.TsCatArrayEncoder.encode"><code class="docutils literal notranslate"><span class="pre">TsCatArrayEncoder.encode()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#encoder.TsCatArrayEncoder.encode_one"><code class="docutils literal notranslate"><span class="pre">TsCatArrayEncoder.encode_one()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#encoder.TsCatArrayEncoder.prepare"><code class="docutils literal notranslate"><span class="pre">TsCatArrayEncoder.prepare()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#encoder.TsNumericEncoder"><code class="docutils literal notranslate"><span class="pre">TsNumericEncoder</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#encoder.TsNumericEncoder.decode"><code class="docutils literal notranslate"><span class="pre">TsNumericEncoder.decode()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#encoder.TsNumericEncoder.encode"><code class="docutils literal notranslate"><span class="pre">TsNumericEncoder.encode()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#encoder.VocabularyEncoder"><code class="docutils literal notranslate"><span class="pre">VocabularyEncoder</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#encoder.VocabularyEncoder.decode"><code class="docutils literal notranslate"><span class="pre">VocabularyEncoder.decode()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#encoder.VocabularyEncoder.encode"><code class="docutils literal notranslate"><span class="pre">VocabularyEncoder.encode()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#encoder.VocabularyEncoder.prepare"><code class="docutils literal notranslate"><span class="pre">VocabularyEncoder.prepare()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="mixer.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">Mixers</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="ensemble.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">Ensemble</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="analysis.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">Analysis</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="helpers.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">Helpers</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="lightwood_philosophy.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">Lightwood</span> <span class="pre">Philosophy</span></code></a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: white" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">lightwood</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active"><code class="xref py py-mod docutils literal notranslate"><span class="pre">Encoders</span></code></li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/encoder.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="encoders">
<h1><code class="xref py py-mod docutils literal notranslate"><span class="pre">Encoders</span></code><a class="headerlink" href="#encoders" title="Permalink to this heading"></a></h1>
<p>Used for encoding data into PyTorch tensors and decoding it from pytorch tensors</p>
<span class="target" id="module-encoder"></span><dl class="py class">
<dt class="sig sig-object py" id="encoder.ArrayEncoder">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">encoder.</span></span><span class="sig-name descname"><span class="pre">ArrayEncoder</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">stop_after</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_target</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">original_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lightwood/encoder/array/array.html#ArrayEncoder"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#encoder.ArrayEncoder" title="Permalink to this definition"></a></dt>
<dd><p>Fits a normalizer for array data.</p>
<p>To encode, <cite>ArrayEncoder</cite> returns a normalized window of previous data.
It can be used for generic arrays, as well as for handling historical target values in time series tasks.</p>
<p>Currently supported normalizing strategies are minmax for numerical arrays, and a simple one-hot for categorical arrays. See <cite>lightwood.encoder.helpers</cite> for more details on each approach.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>stop_after</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – time budget in seconds.</p></li>
<li><p><strong>window</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]) – expected length of array data.</p></li>
<li><p><strong>original_type</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">dtype</span></code>]) – element-wise data type</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="encoder.ArrayEncoder.decode">
<span class="sig-name descname"><span class="pre">decode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lightwood/encoder/array/array.html#ArrayEncoder.decode"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#encoder.ArrayEncoder.decode" title="Permalink to this definition"></a></dt>
<dd><p>Converts data as a list of arrays.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>data</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Tensor</span></code>) – Encoded data prepared by this array encoder</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">Iterable</span></code>]</p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A list of iterable sequences in the original data space</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="encoder.ArrayEncoder.encode">
<span class="sig-name descname"><span class="pre">encode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">column_data</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lightwood/encoder/array/array.html#ArrayEncoder.encode"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#encoder.ArrayEncoder.encode" title="Permalink to this definition"></a></dt>
<dd><p>Encode the properties of a sequence-of-sequence representation</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>column_data</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Iterable</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">Iterable</span></code>]) – Input column data to be encoded</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">Tensor</span></code></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a torch-tensor representing the encoded sequence</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="encoder.ArrayEncoder.prepare">
<span class="sig-name descname"><span class="pre">prepare</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">train_priming_data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dev_priming_data</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lightwood/encoder/array/array.html#ArrayEncoder.prepare"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#encoder.ArrayEncoder.prepare" title="Permalink to this definition"></a></dt>
<dd><p>Prepare the array encoder for sequence data.
:type train_priming_data: <code class="xref py py-class docutils literal notranslate"><span class="pre">Iterable</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">Iterable</span></code>]
:param train_priming_data: Training data of sequences
:type dev_priming_data: <code class="xref py py-class docutils literal notranslate"><span class="pre">Iterable</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">Iterable</span></code>]
:param dev_priming_data: Dev data of sequences</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="encoder.BaseEncoder">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">encoder.</span></span><span class="sig-name descname"><span class="pre">BaseEncoder</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">is_target</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lightwood/encoder/base.html#BaseEncoder"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#encoder.BaseEncoder" title="Permalink to this definition"></a></dt>
<dd><p>Base class for all encoders.</p>
<p>An encoder should return encoded representations of any columnar data.
The procedure for this is defined inside the <cite>encode()</cite> method.</p>
<p>If this encoder is expected to handle an output column, then it also needs to implement the respective <cite>decode()</cite> method that handles the inverse transformation from encoded representations to the final prediction in the original column space.</p>
<p>For encoders that learn representations (as opposed to rule-based), the <cite>prepare()</cite> method will handle all learning logic.</p>
<p>The <cite>to()</cite> method is used to move PyTorch-based encoders to and from a GPU.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>is_target</strong> – Whether the data to encode is the target, as per the problem definition.</p></li>
<li><p><strong>is_timeseries_encoder</strong> – Whether encoder represents sequential/time-series data. Lightwood must provide specific treatment for this kind of encoder</p></li>
<li><p><strong>is_trainable_encoder</strong> – Whether the encoder must return learned representations. Lightwood checks whether this flag is present in order to pass data to the feature representation via the <code class="docutils literal notranslate"><span class="pre">prepare</span></code> statement.</p></li>
</ul>
</dd>
</dl>
<p>Class Attributes:
- is_prepared: Internal flag to signal that the <cite>prepare()</cite> method has been successfully executed.
- is_nn_encoder: Whether the encoder is neural network-based.
- dependencies: list of additional columns that the encoder might need to encode.
- output_size: length of each encoding tensor for a single data point.</p>
<dl class="py method">
<dt class="sig sig-object py" id="encoder.BaseEncoder.decode">
<span class="sig-name descname"><span class="pre">decode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">encoded_data</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lightwood/encoder/base.html#BaseEncoder.decode"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#encoder.BaseEncoder.decode" title="Permalink to this definition"></a></dt>
<dd><p>Given an encoded representation, returns the decoded value. Decoded values may not exist for all encoders (ex: rich text, audio, etc.)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>encoded_data</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Tensor</span></code>) – The input representation in encoded format</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code>]</p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The decoded representation of data, per column, in the original data-type presented.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="encoder.BaseEncoder.encode">
<span class="sig-name descname"><span class="pre">encode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">column_data</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lightwood/encoder/base.html#BaseEncoder.encode"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#encoder.BaseEncoder.encode" title="Permalink to this definition"></a></dt>
<dd><p>Given the approach defined in <cite>prepare()</cite>, encodes column data into a numerical representation to form part of the feature vector.</p>
<p>After all columns are featurized, each encoded vector is concatenated to form a feature vector per row in the dataset.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>column_data</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Iterable</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code>]) – An iterable data structure where all the elements have type that is compatible with the encoder processing type; this may differ per encoder.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">Tensor</span></code></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The encoded representation of data, per column</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="encoder.BaseEncoder.prepare">
<span class="sig-name descname"><span class="pre">prepare</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">priming_data</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lightwood/encoder/base.html#BaseEncoder.prepare"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#encoder.BaseEncoder.prepare" title="Permalink to this definition"></a></dt>
<dd><p>Given ‘priming_data’ (i.e. training data), prepares encoders either through a rule-based (ex: one-hot encoding) or learned (ex: DistilBERT for text) model. This works explicitly on only training data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>priming_data</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Iterable</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code>]) – An iterable data structure where all the elements have type that is compatible with the encoder processing type; this may differ per encoder.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="encoder.BinaryEncoder">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">encoder.</span></span><span class="sig-name descname"><span class="pre">BinaryEncoder</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">is_target</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">handle_unknown</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'use_encoded_value'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lightwood/encoder/categorical/binary.html#BinaryEncoder"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#encoder.BinaryEncoder" title="Permalink to this definition"></a></dt>
<dd><p>Creates a one-hot-encoding for binary class data. Assume two arbitrary categories <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(B\)</span>; representation for them will be as such:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[A &amp;= [1, 0] \
B &amp;= [0, 1]\]</div>
<p>This encoder is a specialized case of one-hot encoding (OHE); unknown categories are explicitly handled as [0, 0]. Unknowns may only be reported if the input row value is NULL (or python <cite>None</cite> type) or if new data, after the encoder is prepared, has examples outside the feature map.</p>
<p>When data is typed with Lightwood, this class is only deployed if an input data type is explicitly recognized as binary (i.e. the column has only 2 unique values like True/False). If future data shows a new category (thus the data is no longer truly binary), this encoder will no longer be appropriate unless you are comfortable mapping ALL new classes as [0, 0].</p>
<p>An encoder can represent a feature column or target column; in this case it represents a target, <cite>is_target</cite> is <cite>True</cite>, and <cite>target_weights</cite>. The <cite>target_weights</cite> parameter enables users to specify how heavily each class should be weighted within a mixer - useful in imbalanced classes.</p>
<p>By default, <cite>dataprep_ml.StatisticalAnalysis</cite> phase will provide <cite>target_weights</cite> as the relative fraction of each class in the data which is important for imbalanced populations; for example, suppose there is a 80/20 imbalanced representation across 3 different classes - <cite>target_weights</cite> will be a vector as such:</p>
<p>target_weights = {“class1”: 0.8, “class2”: 0.2}</p>
<p>Users should note that models will be presented with the inverse of the target weights, <cite>inv_target_weights</cite>, which will perform the 1/target_value_per_class operation. <strong>This means large values will result in small weights for the model</strong>.</p>
</div></blockquote>
<dl class="py method">
<dt class="sig sig-object py" id="encoder.BinaryEncoder.decode">
<span class="sig-name descname"><span class="pre">decode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">encoded_data</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lightwood/encoder/categorical/binary.html#BinaryEncoder.decode"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#encoder.BinaryEncoder.decode" title="Permalink to this definition"></a></dt>
<dd><p>Given encoded data, return in form of original category labels.
The input to <cite>decode</cite> makes no presumption on whether the data is already in OHE form OR not, as it some models may output a set of probabilities of weights assigned to each class. The decoded value will always be the argmax of such a vector.</p>
<p>In the case that the vector is all 0s, the output is decoded as “UNKNOWN”</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>encoded_data</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Tensor</span></code>) – the output of a mixer model</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Decoded values for each data point</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="encoder.BinaryEncoder.decode_probabilities">
<span class="sig-name descname"><span class="pre">decode_probabilities</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">encoded_data</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lightwood/encoder/categorical/binary.html#BinaryEncoder.decode_probabilities"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#encoder.BinaryEncoder.decode_probabilities" title="Permalink to this definition"></a></dt>
<dd><p>Provides decoded answers, as well as a probability assignment to each data point.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>encoded_data</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Tensor</span></code>) – the output of a mixer model</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="xref py py-data docutils literal notranslate"><span class="pre">Tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>], <code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>]], <code class="xref py py-class docutils literal notranslate"><span class="pre">Dict</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>]]</p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Decoded values for each data point, Probability vector for each category, and the reverse map of dimension to category name</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="encoder.BinaryEncoder.encode">
<span class="sig-name descname"><span class="pre">encode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">column_data</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lightwood/encoder/categorical/binary.html#BinaryEncoder.encode"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#encoder.BinaryEncoder.encode" title="Permalink to this definition"></a></dt>
<dd><p>Encodes categories as OHE binary. Unknown/unrecognized classes return [0,0].
:rtype: <code class="xref py py-class docutils literal notranslate"><span class="pre">Tensor</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>column_data</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Iterable</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>]) – Pre-processed data to encode</p>
</dd>
</dl>
<p>:returns Encoded data of form <span class="math notranslate nohighlight">\(N_{rows} x 2\)</span></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="encoder.BinaryEncoder.prepare">
<span class="sig-name descname"><span class="pre">prepare</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">priming_data</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lightwood/encoder/categorical/binary.html#BinaryEncoder.prepare"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#encoder.BinaryEncoder.prepare" title="Permalink to this definition"></a></dt>
<dd><p>Given priming data, create a map/inverse-map corresponding category name to index (and vice versa).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>priming_data</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Iterable</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>]) – Binary data to encode</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="encoder.CatArrayEncoder">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">encoder.</span></span><span class="sig-name descname"><span class="pre">CatArrayEncoder</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">stop_after</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_target</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lightwood/encoder/array/array.html#CatArrayEncoder"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#encoder.CatArrayEncoder" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>stop_after</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – time budget in seconds.</p></li>
<li><p><strong>window</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]) – expected length of array data.</p></li>
<li><p><strong>original_type</strong> – element-wise data type</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="encoder.CatArrayEncoder.decode">
<span class="sig-name descname"><span class="pre">decode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lightwood/encoder/array/array.html#CatArrayEncoder.decode"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#encoder.CatArrayEncoder.decode" title="Permalink to this definition"></a></dt>
<dd><p>Converts data as a list of arrays.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>data</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Tensor</span></code>) – Encoded data prepared by this array encoder</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">Iterable</span></code>]</p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A list of iterable sequences in the original data space</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="encoder.CatArrayEncoder.prepare">
<span class="sig-name descname"><span class="pre">prepare</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">train_priming_data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dev_priming_data</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lightwood/encoder/array/array.html#CatArrayEncoder.prepare"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#encoder.CatArrayEncoder.prepare" title="Permalink to this definition"></a></dt>
<dd><p>Prepare the array encoder for sequence data.
:type train_priming_data: <code class="xref py py-class docutils literal notranslate"><span class="pre">Iterable</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">Iterable</span></code>]
:param train_priming_data: Training data of sequences
:type dev_priming_data: <code class="xref py py-class docutils literal notranslate"><span class="pre">Iterable</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">Iterable</span></code>]
:param dev_priming_data: Dev data of sequences</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="encoder.CategoricalAutoEncoder">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">encoder.</span></span><span class="sig-name descname"><span class="pre">CategoricalAutoEncoder</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">stop_after</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3600</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_target</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_encoded_length</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">desired_error</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.01</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">batch_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">200</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">input_encoder</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lightwood/encoder/categorical/autoencoder.html#CategoricalAutoEncoder"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#encoder.CategoricalAutoEncoder" title="Permalink to this definition"></a></dt>
<dd><p>Trains an autoencoder (AE) to represent categorical information with over 100 categories. This is used to ensure that feature vectors for categorical data with many categories are not excessively large.</p>
<p>The AE defaults to a vector sized 100 but can be adjusted to user preference. It is highly advised NOT to use this encoder to feature engineer your target, as reconstruction accuracy will determine your AE’s ability to decode properly.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>stop_after</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – Stops training with provided time limit (sec)</p></li>
<li><p><strong>is_target</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – Encoder represents target class (NOT recommended)</p></li>
<li><p><strong>max_encoded_length</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – Maximum length of vector represented</p></li>
<li><p><strong>desired_error</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – Threshold for reconstruction accuracy error</p></li>
<li><p><strong>batch_size</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – Minimum batch size while training</p></li>
<li><p><strong>device</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – Name of the device that get_device_from_name will attempt to use</p></li>
<li><p><strong>input_encoder</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>]) – one of <cite>OneHotEncoder</cite> or <cite>SimpleLabelEncoder</cite> to force usage of the underlying input encoder. Note that OHE does not scale for categorical features with high cardinality, while SLE can but is less accurate overall.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="encoder.CategoricalAutoEncoder.decode">
<span class="sig-name descname"><span class="pre">decode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">encoded_data</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lightwood/encoder/categorical/autoencoder.html#CategoricalAutoEncoder.decode"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#encoder.CategoricalAutoEncoder.decode" title="Permalink to this definition"></a></dt>
<dd><p>Decodes from the embedding space, the original categories.</p>
<p>..warning If your reconstruction accuracy is not 100%, the CatAE may not return the correct category.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>encoded_data</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Tensor</span></code>) – A torch tensor of embeddings for category predictions</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>]</p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A list of ‘translated’ categories for each embedding</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="encoder.CategoricalAutoEncoder.encode">
<span class="sig-name descname"><span class="pre">encode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">column_data</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lightwood/encoder/categorical/autoencoder.html#CategoricalAutoEncoder.encode"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#encoder.CategoricalAutoEncoder.encode" title="Permalink to this definition"></a></dt>
<dd><p>Encodes categorical information in column as the compressed vector from the CatAE.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>column_data</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Iterable</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>]) – An iterable of category samples from a column</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">Tensor</span></code></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>An embedding for each sample in original input</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="encoder.CategoricalAutoEncoder.prepare">
<span class="sig-name descname"><span class="pre">prepare</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">train_priming_data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dev_priming_data</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lightwood/encoder/categorical/autoencoder.html#CategoricalAutoEncoder.prepare"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#encoder.CategoricalAutoEncoder.prepare" title="Permalink to this definition"></a></dt>
<dd><p>Creates inputs and prepares a categorical autoencoder (CatAE) for input data. Currently, does not support a dev set; inputs for train and dev are concatenated together to train an autoencoder.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>train_priming_data</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Series</span></code>) – Input training data</p></li>
<li><p><strong>dev_priming_data</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Series</span></code>) – Input dev data (Not supported currently)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="encoder.DatetimeEncoder">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">encoder.</span></span><span class="sig-name descname"><span class="pre">DatetimeEncoder</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">is_target</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lightwood/encoder/datetime/datetime.html#DatetimeEncoder"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#encoder.DatetimeEncoder" title="Permalink to this definition"></a></dt>
<dd><p>This encoder produces an encoded representation for timestamps.</p>
<p>The approach consists on decomposing the timestamp objects into its constituent units (e.g. month, year, etc), and describing each of those with a single value that represents the magnitude in a sensible cycle length.</p>
<dl class="py method">
<dt class="sig sig-object py" id="encoder.DatetimeEncoder.decode">
<span class="sig-name descname"><span class="pre">decode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">encoded_data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_as_datetime</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lightwood/encoder/datetime/datetime.html#DatetimeEncoder.decode"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#encoder.DatetimeEncoder.decode" title="Permalink to this definition"></a></dt>
<dd><p>Given an encoded representation, returns the decoded value. Decoded values may not exist for all encoders (ex: rich text, audio, etc.)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>encoded_data</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Tensor</span></code>) – The input representation in encoded format</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The decoded representation of data, per column, in the original data-type presented.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="encoder.DatetimeEncoder.encode">
<span class="sig-name descname"><span class="pre">encode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lightwood/encoder/datetime/datetime.html#DatetimeEncoder.encode"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#encoder.DatetimeEncoder.encode" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>data</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Series</span></code>]) – a pandas series with numerical dtype, previously cleaned with dataprep_ml</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">Tensor</span></code></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>encoded data, shape (len(data), self.output_size)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="encoder.DatetimeEncoder.prepare">
<span class="sig-name descname"><span class="pre">prepare</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">priming_data</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lightwood/encoder/datetime/datetime.html#DatetimeEncoder.prepare"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#encoder.DatetimeEncoder.prepare" title="Permalink to this definition"></a></dt>
<dd><p>Given ‘priming_data’ (i.e. training data), prepares encoders either through a rule-based (ex: one-hot encoding) or learned (ex: DistilBERT for text) model. This works explicitly on only training data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>priming_data</strong> – An iterable data structure where all the elements have type that is compatible with the encoder processing type; this may differ per encoder.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="encoder.DatetimeNormalizerEncoder">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">encoder.</span></span><span class="sig-name descname"><span class="pre">DatetimeNormalizerEncoder</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">is_target</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sinusoidal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lightwood/encoder/datetime/datetime_sin_normalizer.html#DatetimeNormalizerEncoder"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#encoder.DatetimeNormalizerEncoder" title="Permalink to this definition"></a></dt>
<dd><dl class="py method">
<dt class="sig sig-object py" id="encoder.DatetimeNormalizerEncoder.decode">
<span class="sig-name descname"><span class="pre">decode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">encoded_data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_as_datetime</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lightwood/encoder/datetime/datetime_sin_normalizer.html#DatetimeNormalizerEncoder.decode"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#encoder.DatetimeNormalizerEncoder.decode" title="Permalink to this definition"></a></dt>
<dd><p>Given an encoded representation, returns the decoded value. Decoded values may not exist for all encoders (ex: rich text, audio, etc.)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>encoded_data</strong> – The input representation in encoded format</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The decoded representation of data, per column, in the original data-type presented.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="encoder.DatetimeNormalizerEncoder.encode">
<span class="sig-name descname"><span class="pre">encode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lightwood/encoder/datetime/datetime_sin_normalizer.html#DatetimeNormalizerEncoder.encode"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#encoder.DatetimeNormalizerEncoder.encode" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>data</strong> – # &#64;TODO: receive a consistent data type here; currently either list of lists or pd.Series w/lists</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>encoded data</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="encoder.DatetimeNormalizerEncoder.encode_one">
<span class="sig-name descname"><span class="pre">encode_one</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lightwood/encoder/datetime/datetime_sin_normalizer.html#DatetimeNormalizerEncoder.encode_one"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#encoder.DatetimeNormalizerEncoder.encode_one" title="Permalink to this definition"></a></dt>
<dd><p>Encodes a list of unix_timestamps, or a list of tensors with unix_timestamps
:type data:
:param data: list of unix_timestamps (unix_timestamp resolution is seconds)
:return: a list of vectors</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="encoder.DatetimeNormalizerEncoder.prepare">
<span class="sig-name descname"><span class="pre">prepare</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">priming_data</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lightwood/encoder/datetime/datetime_sin_normalizer.html#DatetimeNormalizerEncoder.prepare"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#encoder.DatetimeNormalizerEncoder.prepare" title="Permalink to this definition"></a></dt>
<dd><p>Given ‘priming_data’ (i.e. training data), prepares encoders either through a rule-based (ex: one-hot encoding) or learned (ex: DistilBERT for text) model. This works explicitly on only training data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>priming_data</strong> – An iterable data structure where all the elements have type that is compatible with the encoder processing type; this may differ per encoder.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="encoder.Img2VecEncoder">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">encoder.</span></span><span class="sig-name descname"><span class="pre">Img2VecEncoder</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">stop_after</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3600</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_target</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(224,</span> <span class="pre">224)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mean</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[0.485,</span> <span class="pre">0.456,</span> <span class="pre">0.406]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">std</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[0.229,</span> <span class="pre">0.224,</span> <span class="pre">0.225]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lightwood/encoder/image/img_2_vec.html#Img2VecEncoder"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#encoder.Img2VecEncoder" title="Permalink to this definition"></a></dt>
<dd><p>Generates encoded representations for images using a pre-trained deep neural network. Inputs must be str-based location of the data.</p>
<p>Without user-specified details, all input images are rescaled to a standard size of 224x224, and normalized using the mean and standard deviation of the ImageNet dataset (as it was used to train the underlying NN).</p>
<p>This encoder currently does not support a <cite>decode()</cite> call; models with an image output will not work.</p>
<p>For more information about the neural network this encoder uses, refer to the <cite>lightwood.encoder.image.helpers.img_to_vec.Img2Vec</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>stop_after</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – time budget, in seconds.</p></li>
<li><p><strong>is_target</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – Whether encoder represents target or not</p></li>
<li><p><strong>scale</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]) – Resize scale of image (x, y)</p></li>
<li><p><strong>mean</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>]) – Mean of pixel values</p></li>
<li><p><strong>std</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>]) – Standard deviation of pixel values</p></li>
<li><p><strong>device</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – Name of the device that get_device_from_name will attempt to use</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="encoder.Img2VecEncoder.decode">
<span class="sig-name descname"><span class="pre">decode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">encoded_values_tensor</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lightwood/encoder/image/img_2_vec.html#Img2VecEncoder.decode"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#encoder.Img2VecEncoder.decode" title="Permalink to this definition"></a></dt>
<dd><p>Currently not supported</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="encoder.Img2VecEncoder.encode">
<span class="sig-name descname"><span class="pre">encode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">images</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lightwood/encoder/image/img_2_vec.html#Img2VecEncoder.encode"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#encoder.Img2VecEncoder.encode" title="Permalink to this definition"></a></dt>
<dd><p>Creates encodings for a list of images; each image is referenced by a filepath or url.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>images</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>]) – list of images, each image is a path to a file or a url.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">Tensor</span></code></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a torch.floatTensor</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="encoder.Img2VecEncoder.prepare">
<span class="sig-name descname"><span class="pre">prepare</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">train_priming_data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dev_priming_data</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lightwood/encoder/image/img_2_vec.html#Img2VecEncoder.prepare"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#encoder.Img2VecEncoder.prepare" title="Permalink to this definition"></a></dt>
<dd><p>Sets an <cite>Img2Vec</cite> object (model) and sets the expected size for encoded representations.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="encoder.Img2VecEncoder.to">
<span class="sig-name descname"><span class="pre">to</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">device</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">available_devices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lightwood/encoder/image/img_2_vec.html#Img2VecEncoder.to"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#encoder.Img2VecEncoder.to" title="Permalink to this definition"></a></dt>
<dd><p>Changes device of model to support CPU/GPU</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>device</strong> – will move the model to this device.</p></li>
<li><p><strong>available_devices</strong> – all available devices as reported by lightwood.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>same object but moved to the target device.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="encoder.MultiHotEncoder">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">encoder.</span></span><span class="sig-name descname"><span class="pre">MultiHotEncoder</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">is_target</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lightwood/encoder/categorical/multihot.html#MultiHotEncoder"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#encoder.MultiHotEncoder" title="Permalink to this definition"></a></dt>
<dd><dl class="py method">
<dt class="sig sig-object py" id="encoder.MultiHotEncoder.decode">
<span class="sig-name descname"><span class="pre">decode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vectors</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lightwood/encoder/categorical/multihot.html#MultiHotEncoder.decode"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#encoder.MultiHotEncoder.decode" title="Permalink to this definition"></a></dt>
<dd><p>Given an encoded representation, returns the decoded value. Decoded values may not exist for all encoders (ex: rich text, audio, etc.)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>encoded_data</strong> – The input representation in encoded format</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The decoded representation of data, per column, in the original data-type presented.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="encoder.MultiHotEncoder.encode">
<span class="sig-name descname"><span class="pre">encode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">column_data</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lightwood/encoder/categorical/multihot.html#MultiHotEncoder.encode"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#encoder.MultiHotEncoder.encode" title="Permalink to this definition"></a></dt>
<dd><p>Given the approach defined in <cite>prepare()</cite>, encodes column data into a numerical representation to form part of the feature vector.</p>
<p>After all columns are featurized, each encoded vector is concatenated to form a feature vector per row in the dataset.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>column_data</strong> – An iterable data structure where all the elements have type that is compatible with the encoder processing type; this may differ per encoder.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The encoded representation of data, per column</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="encoder.MultiHotEncoder.prepare">
<span class="sig-name descname"><span class="pre">prepare</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">priming_data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_dimensions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lightwood/encoder/categorical/multihot.html#MultiHotEncoder.prepare"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#encoder.MultiHotEncoder.prepare" title="Permalink to this definition"></a></dt>
<dd><p>Given ‘priming_data’ (i.e. training data), prepares encoders either through a rule-based (ex: one-hot encoding) or learned (ex: DistilBERT for text) model. This works explicitly on only training data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>priming_data</strong> – An iterable data structure where all the elements have type that is compatible with the encoder processing type; this may differ per encoder.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="encoder.NumArrayEncoder">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">encoder.</span></span><span class="sig-name descname"><span class="pre">NumArrayEncoder</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">stop_after</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_target</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">positive_domain</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lightwood/encoder/array/array.html#NumArrayEncoder"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#encoder.NumArrayEncoder" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>stop_after</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – time budget in seconds.</p></li>
<li><p><strong>window</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]) – expected length of array data.</p></li>
<li><p><strong>original_type</strong> – element-wise data type</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="encoder.NumericEncoder">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">encoder.</span></span><span class="sig-name descname"><span class="pre">NumericEncoder</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_target</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">positive_domain</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lightwood/encoder/numeric/numeric.html#NumericEncoder"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#encoder.NumericEncoder" title="Permalink to this definition"></a></dt>
<dd><p>The numeric encoder takes numbers (float or integer) and converts it into tensors of the form:
<code class="docutils literal notranslate"><span class="pre">[0</span> <span class="pre">if</span> <span class="pre">the</span> <span class="pre">number</span> <span class="pre">is</span> <span class="pre">none,</span> <span class="pre">otherwise</span> <span class="pre">1,</span> <span class="pre">1</span> <span class="pre">if</span> <span class="pre">the</span> <span class="pre">number</span> <span class="pre">is</span> <span class="pre">positive,</span> <span class="pre">otherwise</span> <span class="pre">0,</span> <span class="pre">natural_log(abs(number)),</span> <span class="pre">number/absolute_mean]</span></code></p>
<p>This representation is: <code class="docutils literal notranslate"><span class="pre">[1</span> <span class="pre">if</span> <span class="pre">the</span> <span class="pre">number</span> <span class="pre">is</span> <span class="pre">positive,</span> <span class="pre">otherwise</span> <span class="pre">0,</span> <span class="pre">natural_log(abs(number)),</span> <span class="pre">number/absolute_mean]]</span></code> if encoding target values, since target values can’t be none.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">absolute_mean</span></code> is computed in the <code class="docutils literal notranslate"><span class="pre">prepare</span></code> method and is just the mean of the absolute values of all numbers feed to prepare (which are not none)</p>
<p><code class="docutils literal notranslate"><span class="pre">none</span></code> stands for any number that is an actual python <code class="docutils literal notranslate"><span class="pre">None</span></code> value or any sort of non-numeric value (a string, nan, inf)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data_type</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">dtype</span></code>]) – The data type of the number (integer, float, quantity)</p></li>
<li><p><strong>target_weights</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">Dict</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>]]) – a dictionary of weights to use on the examples.</p></li>
<li><p><strong>is_target</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – Indicates whether the encoder refers to a target column or feature column (True==target)</p></li>
<li><p><strong>positive_domain</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – Forces the encoder to always output positive values</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="encoder.NumericEncoder.decode">
<span class="sig-name descname"><span class="pre">decode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">encoded_values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">decode_log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lightwood/encoder/numeric/numeric.html#NumericEncoder.decode"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#encoder.NumericEncoder.decode" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>encoded_values</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Tensor</span></code>) – The encoded values to decode into single numbers</p></li>
<li><p><strong>decode_log</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>]) – Whether to decode the <code class="docutils literal notranslate"><span class="pre">log</span></code> or <code class="docutils literal notranslate"><span class="pre">linear</span></code> part of the representation, since the encoded vector contains both a log and a linear part</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The decoded array</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="encoder.NumericEncoder.encode">
<span class="sig-name descname"><span class="pre">encode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lightwood/encoder/numeric/numeric.html#NumericEncoder.encode"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#encoder.NumericEncoder.encode" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>data</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Series</span></code>]) – A pandas series or numpy array containing the numbers to be encoded</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A torch tensor with the representations of each number</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="encoder.NumericEncoder.prepare">
<span class="sig-name descname"><span class="pre">prepare</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">priming_data</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lightwood/encoder/numeric/numeric.html#NumericEncoder.prepare"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#encoder.NumericEncoder.prepare" title="Permalink to this definition"></a></dt>
<dd><p>“NumericalEncoder” uses a rule-based form to prepare results on training (priming) data. The averages etc. are taken from this distribution.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>priming_data</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Series</span></code>) – an iterable data structure containing numbers numbers which will be used to compute the values used for normalizing the encoded representations</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="encoder.OneHotEncoder">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">encoder.</span></span><span class="sig-name descname"><span class="pre">OneHotEncoder</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">is_target</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_unknown</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lightwood/encoder/categorical/onehot.html#OneHotEncoder"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#encoder.OneHotEncoder" title="Permalink to this definition"></a></dt>
<dd><p>Creates a one-hot encoding (OHE) for categorical data. One-hot encoding represents categorical information as a vector where each individual dimension corresponds to a category. A category has a 1:1 mapping between dimension indicated by a “1” in that position. For example, imagine 3 categories, <span class="math notranslate nohighlight">\(A\)</span>, <span class="math notranslate nohighlight">\(B\)</span>, and <span class="math notranslate nohighlight">\(C\)</span>; these can be represented as follows:</p>
<div class="math notranslate nohighlight">
\[A &amp;= [1, 0, 0] \
B &amp;= [0, 1, 0] \
C &amp;= [0, 0, 1]\]</div>
<dl class="simple">
<dt>The OHE encoder operates in 2 modes:</dt><dd><ol class="arabic simple">
<li><p>“use_unknown=True”: Makes an <span class="math notranslate nohighlight">\(N+1\)</span> length vector for <span class="math notranslate nohighlight">\(N\)</span> categories, the first index always corresponds to the unknown category.</p></li>
<li><p>“use_unknown=False”: Makes an <span class="math notranslate nohighlight">\(N\)</span> length vector for <span class="math notranslate nohighlight">\(N\)</span> categories, where an empty vector of 0s indicates an unknown/missing category.</p></li>
</ol>
</dd>
</dl>
<p>An encoder can represent a feature column or target column; in this case it represents a target, <cite>is_target</cite> is <cite>True</cite>, and <cite>target_weights</cite>. The <cite>target_weights</cite> parameter enables users to specify how heavily each class should be weighted within a mixer - useful in imbalanced classes.</p>
<p>By default, <cite>dataprep_ml.StatisticalAnalysis</cite> phase will provide <cite>target_weights</cite> as the relative fraction of each class in the data which is important for imbalanced populations; for example, suppose there is a 80/05/15 imbalanced representation across 3 different classes - <cite>target_weights</cite> will be a vector as such:</p>
<p>target_weights = {“class1”: 0.8, “class2”: 0.05, “class3”: 0.15}</p>
<p>Users should note that models will be presented with the inverse of the target weights, <cite>inv_target_weights</cite>, which will perform the 1/target_value_per_class operation. <strong>This means large values will result in small weights for the model</strong>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>is_target</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – True if this encoder featurizes the target column</p></li>
<li><p><strong>target_weights</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">Dict</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>]]) – Percentage of total population represented by each category (between [0, 1]).</p></li>
<li><p><strong>mode</strong> – True uses an extra dimension to account for unknown/out-of-distribution categories</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="encoder.OneHotEncoder.decode">
<span class="sig-name descname"><span class="pre">decode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">encoded_data</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lightwood/encoder/categorical/onehot.html#OneHotEncoder.decode"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#encoder.OneHotEncoder.decode" title="Permalink to this definition"></a></dt>
<dd><p>Decodes OHE mapping into the original categories. Since this approach uses an argmax, decoding flexibly works either on logits or an explicitly OHE vector.</p>
<dl class="field-list simple">
<dt class="field-odd">Param<span class="colon">:</span></dt>
<dd class="field-odd"><p>encoded_data:</p>
</dd>
</dl>
<p>:returns Returns the original category names for encoded data.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="encoder.OneHotEncoder.decode_probabilities">
<span class="sig-name descname"><span class="pre">decode_probabilities</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">encoded_data</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lightwood/encoder/categorical/onehot.html#OneHotEncoder.decode_probabilities"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#encoder.OneHotEncoder.decode_probabilities" title="Permalink to this definition"></a></dt>
<dd><p>Provides decoded answers, as well as a probability assignment to each data point.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>encoded_data</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Tensor</span></code>) – the output of a mixer model</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="xref py py-data docutils literal notranslate"><span class="pre">Tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>], <code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>]], <code class="xref py py-class docutils literal notranslate"><span class="pre">Dict</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>]]</p>
</dd>
</dl>
<p>:returns Decoded values for each data point, Probability vector for each category, and the reverse map of dimension to category name</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="encoder.OneHotEncoder.encode">
<span class="sig-name descname"><span class="pre">encode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">column_data</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lightwood/encoder/categorical/onehot.html#OneHotEncoder.encode"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#encoder.OneHotEncoder.encode" title="Permalink to this definition"></a></dt>
<dd><p>Encodes pre-processed data into OHE. Unknown/unrecognized classes vector of all 0s.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>column_data</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Iterable</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>]) – Pre-processed data to encode</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">Tensor</span></code></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Encoded data of form <span class="math notranslate nohighlight">\(N_{rows} x N_{categories}\)</span></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="encoder.OneHotEncoder.prepare">
<span class="sig-name descname"><span class="pre">prepare</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">priming_data</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lightwood/encoder/categorical/onehot.html#OneHotEncoder.prepare"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#encoder.OneHotEncoder.prepare" title="Permalink to this definition"></a></dt>
<dd><p>Prepares the OHE Encoder by creating a dictionary mapping.</p>
<p>Unknown categories must be explicitly handled as python <cite>None</cite> types.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="encoder.PretrainedLangEncoder">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">encoder.</span></span><span class="sig-name descname"><span class="pre">PretrainedLangEncoder</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">stop_after</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_target</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">batch_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_position_embeddings</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frozen</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">epochs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">embed_mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lightwood/encoder/text/pretrained.html#PretrainedLangEncoder"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#encoder.PretrainedLangEncoder" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>is_target</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – Whether this encoder represents the target. NOT functional for text generation yet.</p></li>
<li><p><strong>batch_size</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – size of batch while fine-tuning</p></li>
<li><p><strong>max_position_embeddings</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]) – max sequence length of input text</p></li>
<li><p><strong>frozen</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – If True, freezes transformer layers during training.</p></li>
<li><p><strong>epochs</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – number of epochs to train model with</p></li>
<li><p><strong>output_type</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>]) – Data dtype of the target; if categorical/binary, the option to return logits is possible.</p></li>
<li><p><strong>embed_mode</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – If True, assumes the output of the encode() step is the CLS embedding (this can be trained or not). If False, returns the logits of the tuned task.</p></li>
<li><p><strong>device</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – name of the device that get_device_from_name will attempt to use.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="encoder.PretrainedLangEncoder.decode">
<span class="sig-name descname"><span class="pre">decode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">encoded_values_tensor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_length</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lightwood/encoder/text/pretrained.html#PretrainedLangEncoder.decode"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#encoder.PretrainedLangEncoder.decode" title="Permalink to this definition"></a></dt>
<dd><p>Text generation via decoding is not supported.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="encoder.PretrainedLangEncoder.encode">
<span class="sig-name descname"><span class="pre">encode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">column_data</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lightwood/encoder/text/pretrained.html#PretrainedLangEncoder.encode"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#encoder.PretrainedLangEncoder.encode" title="Permalink to this definition"></a></dt>
<dd><p>Converts each text example in a column into encoded state. This can be either a vector embedding of the [CLS] token (represents the full text input) OR the logits prediction of the output.</p>
<p>The transformer model is of form:
transformer base + pre-classifier linear layer + classifier layer</p>
<p>The embedding returned is of the [CLS] token after the pre-classifier layer; from internal testing, we found the latent space most highly separated across classes.</p>
<p>If the encoder represents the logits in classification, returns a soft-maxed output of the class vector.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>column_data</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Iterable</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>]) – List of text data as strings</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">Tensor</span></code></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Embedded vector N_rows x Nembed_dim OR logits vector N_rows x N_classes depending on if <cite>embed_mode</cite> is True or not.</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="encoder.PretrainedLangEncoder.is_trainable_encoder">
<span class="sig-name descname"><span class="pre">is_trainable_encoder</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></em><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">True</span></em><a class="headerlink" href="#encoder.PretrainedLangEncoder.is_trainable_encoder" title="Permalink to this definition"></a></dt>
<dd><p>//arxiv.org/abs/1910.01108).</p>
<p>In certain text tasks, this model can use a transformer to automatically fine-tune on a class of interest (providing there is a 2 column dataset, where the input column is text).</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Creates a contextualized embedding to represent input text via the [CLS] token vector from DistilBERT (transformers). (Sanh et al. 2019 - https</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="encoder.PretrainedLangEncoder.prepare">
<span class="sig-name descname"><span class="pre">prepare</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">train_priming_data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dev_priming_data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">encoded_target_values</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lightwood/encoder/text/pretrained.html#PretrainedLangEncoder.prepare"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#encoder.PretrainedLangEncoder.prepare" title="Permalink to this definition"></a></dt>
<dd><p>Fine-tunes a transformer on the priming data.</p>
<p>Transformer is fine-tuned with weight-decay on training split.</p>
<p>Train + Dev are concatenated together and a transformer is then fine tuned with weight-decay applied on the transformer parameters. The option to freeze the underlying transformer and only train a linear layer exists if <cite>frozen=True</cite>. This trains faster, with the exception that the performance is often lower than fine-tuning on internal benchmarks.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>train_priming_data</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Series</span></code>) – Text data in the train set</p></li>
<li><p><strong>dev_priming_data</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Series</span></code>) – Text data in the dev set</p></li>
<li><p><strong>encoded_target_values</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Tensor</span></code>) – Encoded target labels in Nrows x N_output_dimension</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="encoder.PretrainedLangEncoder.to">
<span class="sig-name descname"><span class="pre">to</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">device</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">available_devices</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lightwood/encoder/text/pretrained.html#PretrainedLangEncoder.to"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#encoder.PretrainedLangEncoder.to" title="Permalink to this definition"></a></dt>
<dd><p>Converts encoder models to device specified (CPU/GPU)</p>
<p>Transformers are LARGE models, please run on GPU for fastest implementation.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="encoder.ShortTextEncoder">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">encoder.</span></span><span class="sig-name descname"><span class="pre">ShortTextEncoder</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">is_target</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lightwood/encoder/text/short.html#ShortTextEncoder"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#encoder.ShortTextEncoder" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>is_target</strong> – </p></li>
<li><p><strong>mode</strong> – None or “concat” or “mean”.
When None, it will be set automatically based on is_target:
(is_target) -&gt; ‘concat’
(not is_target) -&gt; ‘mean’</p></li>
<li><p><strong>device</strong> – name of the device that get_device_from_name will attempt to use.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="encoder.ShortTextEncoder.decode">
<span class="sig-name descname"><span class="pre">decode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vectors</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lightwood/encoder/text/short.html#ShortTextEncoder.decode"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#encoder.ShortTextEncoder.decode" title="Permalink to this definition"></a></dt>
<dd><p>Given an encoded representation, returns the decoded value. Decoded values may not exist for all encoders (ex: rich text, audio, etc.)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>encoded_data</strong> – The input representation in encoded format</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The decoded representation of data, per column, in the original data-type presented.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="encoder.ShortTextEncoder.encode">
<span class="sig-name descname"><span class="pre">encode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">column_data</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lightwood/encoder/text/short.html#ShortTextEncoder.encode"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#encoder.ShortTextEncoder.encode" title="Permalink to this definition"></a></dt>
<dd><p>Given the approach defined in <cite>prepare()</cite>, encodes column data into a numerical representation to form part of the feature vector.</p>
<p>After all columns are featurized, each encoded vector is concatenated to form a feature vector per row in the dataset.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>column_data</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>]) – An iterable data structure where all the elements have type that is compatible with the encoder processing type; this may differ per encoder.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">Tensor</span></code></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The encoded representation of data, per column</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="encoder.ShortTextEncoder.prepare">
<span class="sig-name descname"><span class="pre">prepare</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">priming_data</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lightwood/encoder/text/short.html#ShortTextEncoder.prepare"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#encoder.ShortTextEncoder.prepare" title="Permalink to this definition"></a></dt>
<dd><p>Given ‘priming_data’ (i.e. training data), prepares encoders either through a rule-based (ex: one-hot encoding) or learned (ex: DistilBERT for text) model. This works explicitly on only training data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>priming_data</strong> – An iterable data structure where all the elements have type that is compatible with the encoder processing type; this may differ per encoder.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="encoder.SimpleLabelEncoder">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">encoder.</span></span><span class="sig-name descname"><span class="pre">SimpleLabelEncoder</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">is_target</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lightwood/encoder/categorical/simple_label.html#SimpleLabelEncoder"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#encoder.SimpleLabelEncoder" title="Permalink to this definition"></a></dt>
<dd><p>Simple encoder that assigns a unique integer to every observed label.</p>
<p>Allocates an <cite>unknown</cite> label by default to index 0.</p>
<p>Labels must be exact matches between inference and training (e.g. no .lower() on strings is performed here).</p>
<dl class="py method">
<dt class="sig sig-object py" id="encoder.SimpleLabelEncoder.decode">
<span class="sig-name descname"><span class="pre">decode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">encoded_values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lightwood/encoder/categorical/simple_label.html#SimpleLabelEncoder.decode"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#encoder.SimpleLabelEncoder.decode" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>normalize</strong> – can be used to temporarily return unnormalized values</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code>]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="encoder.SimpleLabelEncoder.encode">
<span class="sig-name descname"><span class="pre">encode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lightwood/encoder/categorical/simple_label.html#SimpleLabelEncoder.encode"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#encoder.SimpleLabelEncoder.encode" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>normalize</strong> – can be used to temporarily return unnormalized values</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">Tensor</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="encoder.SimpleLabelEncoder.prepare">
<span class="sig-name descname"><span class="pre">prepare</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">priming_data</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lightwood/encoder/categorical/simple_label.html#SimpleLabelEncoder.prepare"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#encoder.SimpleLabelEncoder.prepare" title="Permalink to this definition"></a></dt>
<dd><p>Given ‘priming_data’ (i.e. training data), prepares encoders either through a rule-based (ex: one-hot encoding) or learned (ex: DistilBERT for text) model. This works explicitly on only training data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>priming_data</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Series</span></code>]) – An iterable data structure where all the elements have type that is compatible with the encoder processing type; this may differ per encoder.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="encoder.TimeSeriesEncoder">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">encoder.</span></span><span class="sig-name descname"><span class="pre">TimeSeriesEncoder</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">stop_after</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_target</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">original_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lightwood/encoder/time_series/ts.html#TimeSeriesEncoder"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#encoder.TimeSeriesEncoder" title="Permalink to this definition"></a></dt>
<dd><p>Time series encoder. This module will pass the normalized series values, along with moving averages taken from the series’ last <cite>window</cite> values.
:type stop_after: <code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>
:param stop_after: time budget in seconds.
:type window: <code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]
:param window: expected length of array data.
:type original_type: <code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">dtype</span></code>]
:param original_type: element-wise data type</p>
<dl class="py method">
<dt class="sig sig-object py" id="encoder.TimeSeriesEncoder.decode">
<span class="sig-name descname"><span class="pre">decode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lightwood/encoder/time_series/ts.html#TimeSeriesEncoder.decode"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#encoder.TimeSeriesEncoder.decode" title="Permalink to this definition"></a></dt>
<dd><p>Converts data as a list of arrays. Removes all encoded moving average information.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>data</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Tensor</span></code>) – Encoded data prepared by this array encoder</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">Iterable</span></code>]</p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A list of iterable sequences in the original data space</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="encoder.TimeSeriesEncoder.encode">
<span class="sig-name descname"><span class="pre">encode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">column_data</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lightwood/encoder/time_series/ts.html#TimeSeriesEncoder.encode"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#encoder.TimeSeriesEncoder.encode" title="Permalink to this definition"></a></dt>
<dd><p>Encodes time series data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>column_data</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Iterable</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">Iterable</span></code>]) – Input column data to be encoded</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">Tensor</span></code></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a torch tensor representing the encoded time series.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="encoder.TsArrayNumericEncoder">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">encoder.</span></span><span class="sig-name descname"><span class="pre">TsArrayNumericEncoder</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">timesteps</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_target</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">positive_domain</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grouped_by</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nan</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lightwood/encoder/array/ts_num_array.html#TsArrayNumericEncoder"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#encoder.TsArrayNumericEncoder" title="Permalink to this definition"></a></dt>
<dd><p>This encoder handles arrays of numerical time series data by wrapping the numerical encoder with behavior specific to time series tasks.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>timesteps</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – length of forecasting horizon, as defined by TimeseriesSettings.window.</p></li>
<li><p><strong>is_target</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – whether this encoder corresponds to the target column.</p></li>
<li><p><strong>positive_domain</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – whether the column domain is expected to be positive numbers.</p></li>
<li><p><strong>grouped_by</strong> – what columns, if any, are considered to group the original column and yield multiple time series.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="encoder.TsArrayNumericEncoder.decode">
<span class="sig-name descname"><span class="pre">decode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">encoded_values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dependency_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lightwood/encoder/array/ts_num_array.html#TsArrayNumericEncoder.decode"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#encoder.TsArrayNumericEncoder.decode" title="Permalink to this definition"></a></dt>
<dd><p>Decodes a list of encoded arrays into values in their original domains.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>encoded_values</strong> – encoded slices of numerical time series.</p></li>
<li><p><strong>dependency_data</strong> – used to determine the correct normalizer for the input.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>]</p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a list of decoded time series arrays.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="encoder.TsArrayNumericEncoder.decode_one">
<span class="sig-name descname"><span class="pre">decode_one</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">encoded_value</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dependency_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lightwood/encoder/array/ts_num_array.html#TsArrayNumericEncoder.decode_one"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#encoder.TsArrayNumericEncoder.decode_one" title="Permalink to this definition"></a></dt>
<dd><p>Decodes a single window of a time series into its original domain.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>encoded_value</strong> – encoded slice of a numerical time series.</p></li>
<li><p><strong>dependency_data</strong> – used to determine the correct normalizer for the input.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a list of length TimeseriesSettings.window with decoded values for the forecasted time series.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="encoder.TsArrayNumericEncoder.encode">
<span class="sig-name descname"><span class="pre">encode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dependency_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lightwood/encoder/array/ts_num_array.html#TsArrayNumericEncoder.encode"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#encoder.TsArrayNumericEncoder.encode" title="Permalink to this definition"></a></dt>
<dd><p>Encodes a list of time series arrays using the underlying time series numerical encoder.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Iterable</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">Iterable</span></code>]) – list of numerical values to encode. Its length is determined by the tss.window parameter, and all data points belong to the same time series.</p></li>
<li><p><strong>dependency_data</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">Dict</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>]]) – dict with values of each group_by column for the time series, used to retrieve the correct normalizer.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">Tensor</span></code></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>list of encoded time series arrays. Tensor is (len(data), N x K)-shaped, where N: self.data_window and K: sub-encoder # of output features.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="encoder.TsArrayNumericEncoder.prepare">
<span class="sig-name descname"><span class="pre">prepare</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">priming_data</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lightwood/encoder/array/ts_num_array.html#TsArrayNumericEncoder.prepare"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#encoder.TsArrayNumericEncoder.prepare" title="Permalink to this definition"></a></dt>
<dd><p>This method prepares the underlying time series numerical encoder.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="encoder.TsCatArrayEncoder">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">encoder.</span></span><span class="sig-name descname"><span class="pre">TsCatArrayEncoder</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">timesteps</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_target</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grouped_by</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lightwood/encoder/array/ts_cat_array.html#TsCatArrayEncoder"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#encoder.TsCatArrayEncoder" title="Permalink to this definition"></a></dt>
<dd><p>This encoder handles arrays of categorical time series data by wrapping the OHE encoder with behavior specific to time series tasks.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>timesteps</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – length of forecasting horizon, as defined by TimeseriesSettings.window.</p></li>
<li><p><strong>is_target</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – whether this encoder corresponds to the target column.</p></li>
<li><p><strong>grouped_by</strong> – what columns, if any, are considered to group the original column and yield multiple time series.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="encoder.TsCatArrayEncoder.decode">
<span class="sig-name descname"><span class="pre">decode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">encoded_values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dependency_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lightwood/encoder/array/ts_cat_array.html#TsCatArrayEncoder.decode"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#encoder.TsCatArrayEncoder.decode" title="Permalink to this definition"></a></dt>
<dd><p>Decodes a list of encoded arrays into values in their original domains.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>encoded_values</strong> – encoded slices of numerical time series.</p></li>
<li><p><strong>dependency_data</strong> – used to determine the correct normalizer for the input.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>]</p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a list of decoded time series arrays.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="encoder.TsCatArrayEncoder.decode_one">
<span class="sig-name descname"><span class="pre">decode_one</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">encoded_value</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lightwood/encoder/array/ts_cat_array.html#TsCatArrayEncoder.decode_one"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#encoder.TsCatArrayEncoder.decode_one" title="Permalink to this definition"></a></dt>
<dd><p>Decodes a single window of a time series into its original domain.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>encoded_value</strong> – encoded slice of a numerical time series.</p></li>
<li><p><strong>dependency_data</strong> – used to determine the correct normalizer for the input.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a list of length TimeseriesSettings.window with decoded values for the forecasted time series.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="encoder.TsCatArrayEncoder.encode">
<span class="sig-name descname"><span class="pre">encode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dependency_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lightwood/encoder/array/ts_cat_array.html#TsCatArrayEncoder.encode"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#encoder.TsCatArrayEncoder.encode" title="Permalink to this definition"></a></dt>
<dd><p>Encodes a list of time series arrays using the underlying time series numerical encoder.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Iterable</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">Iterable</span></code>]) – list of numerical values to encode. Its length is determined by the tss.window parameter, and all data points belong to the same time series.</p></li>
<li><p><strong>dependency_data</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">Dict</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>]]) – dict with values of each group_by column for the time series, used to retrieve the correct normalizer.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">Tensor</span></code></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>list of encoded time series arrays. Tensor is (len(data), N x K)-shaped, where N: self.data_window and K: sub-encoder # of output features.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="encoder.TsCatArrayEncoder.encode_one">
<span class="sig-name descname"><span class="pre">encode_one</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lightwood/encoder/array/ts_cat_array.html#TsCatArrayEncoder.encode_one"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#encoder.TsCatArrayEncoder.encode_one" title="Permalink to this definition"></a></dt>
<dd><p>Encodes a single windowed slice of any given time series.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>data</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Iterable</span></code>) – windowed slice of a numerical time series.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">Tensor</span></code></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>an encoded time series array, as per the underlying <cite>TsNumericEncoder</cite> object.</p>
</dd>
</dl>
<p>The output of this encoder for all time steps is concatenated, so the final shape of the tensor is (1, NxK), where N: self.data_window and K: sub-encoder # of output features.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="encoder.TsCatArrayEncoder.prepare">
<span class="sig-name descname"><span class="pre">prepare</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">priming_data</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lightwood/encoder/array/ts_cat_array.html#TsCatArrayEncoder.prepare"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#encoder.TsCatArrayEncoder.prepare" title="Permalink to this definition"></a></dt>
<dd><p>This method prepares the underlying time series numerical encoder.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="encoder.TsNumericEncoder">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">encoder.</span></span><span class="sig-name descname"><span class="pre">TsNumericEncoder</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">is_target</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">positive_domain</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grouped_by</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lightwood/encoder/numeric/ts_numeric.html#TsNumericEncoder"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#encoder.TsNumericEncoder" title="Permalink to this definition"></a></dt>
<dd><p>Variant of vanilla numerical encoder, supports dynamic mean re-scaling</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data_type</strong> – The data type of the number (integer, float, quantity)</p></li>
<li><p><strong>target_weights</strong> – a dictionary of weights to use on the examples.</p></li>
<li><p><strong>is_target</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – Indicates whether the encoder refers to a target column or feature column (True==target)</p></li>
<li><p><strong>positive_domain</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – Forces the encoder to always output positive values</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="encoder.TsNumericEncoder.decode">
<span class="sig-name descname"><span class="pre">decode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">encoded_values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">decode_log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dependency_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lightwood/encoder/numeric/ts_numeric.html#TsNumericEncoder.decode"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#encoder.TsNumericEncoder.decode" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>encoded_values</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Tensor</span></code>) – The encoded values to decode into single numbers</p></li>
<li><p><strong>decode_log</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>]) – Whether to decode the <code class="docutils literal notranslate"><span class="pre">log</span></code> or <code class="docutils literal notranslate"><span class="pre">linear</span></code> part of the representation, since the encoded vector contains both a log and a linear part</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The decoded array</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="encoder.TsNumericEncoder.encode">
<span class="sig-name descname"><span class="pre">encode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dependency_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lightwood/encoder/numeric/ts_numeric.html#TsNumericEncoder.encode"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#encoder.TsNumericEncoder.encode" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Series</span></code>]) – A pandas series containing the numbers to be encoded</p></li>
<li><p><strong>dependency_data</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Dict</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">Series</span></code>]]) – dict with grouped_by column info, to retrieve the correct normalizer for each datum</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A torch tensor with the representations of each number</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="encoder.VocabularyEncoder">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">encoder.</span></span><span class="sig-name descname"><span class="pre">VocabularyEncoder</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">is_target</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lightwood/encoder/text/vocab.html#VocabularyEncoder"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#encoder.VocabularyEncoder" title="Permalink to this definition"></a></dt>
<dd><dl class="py method">
<dt class="sig sig-object py" id="encoder.VocabularyEncoder.decode">
<span class="sig-name descname"><span class="pre">decode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">encoded_values_tensor</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lightwood/encoder/text/vocab.html#VocabularyEncoder.decode"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#encoder.VocabularyEncoder.decode" title="Permalink to this definition"></a></dt>
<dd><p>Given an encoded representation, returns the decoded value. Decoded values may not exist for all encoders (ex: rich text, audio, etc.)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>encoded_data</strong> – The input representation in encoded format</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The decoded representation of data, per column, in the original data-type presented.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="encoder.VocabularyEncoder.encode">
<span class="sig-name descname"><span class="pre">encode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">column_data</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lightwood/encoder/text/vocab.html#VocabularyEncoder.encode"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#encoder.VocabularyEncoder.encode" title="Permalink to this definition"></a></dt>
<dd><p>Given the approach defined in <cite>prepare()</cite>, encodes column data into a numerical representation to form part of the feature vector.</p>
<p>After all columns are featurized, each encoded vector is concatenated to form a feature vector per row in the dataset.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>column_data</strong> – An iterable data structure where all the elements have type that is compatible with the encoder processing type; this may differ per encoder.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The encoded representation of data, per column</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="encoder.VocabularyEncoder.prepare">
<span class="sig-name descname"><span class="pre">prepare</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">priming_data</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lightwood/encoder/text/vocab.html#VocabularyEncoder.prepare"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#encoder.VocabularyEncoder.prepare" title="Permalink to this definition"></a></dt>
<dd><p>Given ‘priming_data’ (i.e. training data), prepares encoders either through a rule-based (ex: one-hot encoding) or learned (ex: DistilBERT for text) model. This works explicitly on only training data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>priming_data</strong> – An iterable data structure where all the elements have type that is compatible with the encoder processing type; this may differ per encoder.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="data.html" class="btn btn-neutral float-left" title="Data" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="mixer.html" class="btn btn-neutral float-right" title="Mixers" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2017-2024, MindsDB.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>